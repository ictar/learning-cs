原文：[ Design Philosophy On Data And Semantics](https://www.goinggo.net/2017/06/design-philosophy-on-data-and-semantics.html)

---


### 前言

这是一个包含四个部分的系列文，它将帮助你理解 Go 中的指针、堆栈、逃逸分析和值/指针语义背后的机制和设计。这是最后篇。本文着重于数据以及在代码中应用值/指针语义的设计哲学。

该序列文四个部分的索引： 
1) [堆栈和指针的语言机制](https://www.goinggo.net/2017/05/language-mechanics-on-stacks-and-pointers.html)  
2) [逃逸分析的语言机制](https://www.goinggo.net/2017/05/language-mechanics-on-escape-analysis.html)  
3) [内存概要的语言机制](https://www.goinggo.net/2017/06/language-mechanics-on-memory-profiling.html)  
4) [数据和语义上的设计哲学](https://www.goinggo.net/2017/06/design-philosophy-on-data-and-semantics.html)

### 设计哲学

**_”值语义将值放在堆栈上，从而减轻了垃圾回收器（GC）的压力。但是，值语义要求存储、跟踪和维护任意给定值的各个副本。指针语义把值放在堆上，这可能会对 GC 造成压力。但是，指针语义是有效的，因为只需要存储、跟踪和维护一个值。“ \- Bill Kennedy_**

如果想在整个软件中保持完整性和可读性，那么对于给定类型的数据，值/指针语义的一致使用至关重要。为什么？因为，如果你在函数间传递数据时修改数据的语义，那么会让代码的清晰一致的思维模型的维护变得困难。代码库和团队的规模变得越大，出现在代码库中的错误、数据竞争和副作用就越多。

我想从一组设计哲学开始，这些哲学驱动了语义选择的指导原则。

#### 思维模型

**_"让我们想象一个最终包含了一百万行甚至更多行代码的项目。这类项目在现今美国成功的可能性非常低，远低于 50%。这是个颇有争议的问题。“ - Tom Love (Objective C 的发明者)_**

Tom 还提到，一盒复印纸可以容纳 10 万行代码。花点时间打满一盒复印纸。你可以为这盒代码的百分之多少维护一种思维模型呢？

我相信，要求一个开发人员为超过一叠纸（约 1 万行）的代码维护一种思维模型就已经是要求多了点。但是，如果我们继续假设每个开发人员约有 1 万行代码，那么一个一百万行代码的代码库就需要一个 100 个开发人员组成的团队来维护。也就是说，需要对 100 个人进行协调、分组、跟踪和持续沟通。现在，看看你目前这个 1 到 10 个开发人员组成的团队。如果代码规模小得多的话，你们会做得多好？对于每个开发者 1 万行代码而言，你的代码库大小是否与团队大小匹配呢？

#### 调试

**_"最棘手的错误在于你对当前情况的思维模型的错误，因此，你根本看不到问题。" \- Brian Kernighan_**

我不相信调试器，除非你已经丢失了你的代码的思维模型，并且现在正在浪费精力尝试理解问题。如果调试器被滥用的话，它们就变得邪恶了，并且当调试器已经成为任何可观察到的错误的第一处理方式的时候，你就知道你在滥用调试器了。

如果你在生产上遇到问题，那么你会要什么呢？是的，日志。如果在开发期间，日志不起作用，那么当生产出现错误当时候，它们肯定也不起作用。日志要求我们对代码库具备思维模型，以便于你阅读代码查找错误。

#### 可读性

**_"C 是我见过在力量和表现力之间平衡最好对语言。你可以通过编程直接简单地完成几乎所有你想做对事情，并且对于机器将要发生对事情你会有一个很好的思维模型。你可以合理预测运行速度，知道即将发生什么……。" \- Brian Kernighan_**

我相信 Brian 的这段话同样适用于 Go。维护这种“思维模型”就是一切。它提高了完整性、可读性和简单性。这些是编写良好的软件的基石，使它得以维护并持续一段时间。编写对给定类型的数据保持一致的值/指针语义的使用的代码，是实现此目的的重要方法。

#### 面向对象的设计

**_"如果你不了解数据，那么你就不了解问题。这是因为，所有问题都是唯一的，并且特定于你正使用的数据。当数据改变时，问题也随之改变。当问题在改变，算法（数据转换）也需要随之改变。" \- Bill Kennedy_**

想想吧。你处理的每个问题都是数据转换问题。你写的每个函数，运行的每个程序，都需要一些输入数据并产生一些输出数据。从这个角度来看，软件的思维模型就是对这些数据转换的理解（例如，如何在代码库中组织和应用）。“少即是多”的态度对于用更少的层、更少的语句、泛化、更少的复杂性和更少的努力来解决这些问题至关重要。这使得你和你的团队的工作变得更加轻松，也使得硬件更易于执行这些数据转换。

#### 类型（就是生命）

**_"完整性意味着，每一次分配、每一次内存的读取和每一次内存的写入都是准确、一致且高效的。类型系统对于确保我们具有这种微观的完整性至关重要。" \- William Kennedy_**

如果数据驱动你做任何事情，那么代表数据的类型至关重要。我说“类型就是声明”，因为类型为编译器提供了确保数据完整性的能力。类型还驱动并指示了语义规则，代码在操作数据时必须尊重这些规则。这就是开始正确使用值/指针语义的地方：使用类型。

#### 数据（具有功能）

**_"当数据具有某种功能是可行或者合理的时候，方法才有效。" \- William Kennedy_**

值/指针语义的想法并没有打动 Go 开发人员，直到他们必须决定某个方法的接受器类型。这是我见过的一个经常出现的问题：我应该使用值接收器呢，还是指针接收器？每当我听到这个问题，我就知道这个开发者并没有很好地了解这些语义。

方法的目的是为数据提功能。想想吧。数据可以执行某些操作。我一直希望焦点集中在数据上，因为是数据驱动了你的程序的能力。数据驱动了你编写的算法，放置的封装以及可以实现的功能。

#### 多态性

**_"多态性意味着你写了某个程序，并且其行为根据它所操作的数据的不同而不同。" \- Tom Kurtz (BASIC 的发明者)_**

我喜欢 Tom 上面说的这句话。根据函数所操作的数据，它的行为可能有所不同。数据的这种行为使得函数可以与它们可以操作的具体的数据类型解耦。这是数据具有功能的一个核心原因。这种想法正是架构和设计可以适应变化的系统的基石。

#### 原型优先方法

**_"除非开发人员对于软件的用途有一个非常好的了解，否则，该软件很有可能表现不佳。如果开发人员不能很好地了解和理解应用，那么，获得尽可能多的用户输入和经验就至关重要。" \- Brian Kernighan_**

我希望你始终先关注于理解实现数据转换以解决问题所需的具体数据和算法。采取这种原型优先方法，并编写也可以部署在生产上（如果这样做合理可行）的具体实现。一旦有了一个可行的具体实现，并且一旦你了解了什么可行以及什么不可行，就应该专注于重构，通过赋予数据功能，以解耦具体数据的实现。

### 语义准则

你必须决定使用何种语义，在声明某个特定的数据类型时时使用值还是指针。接受或者返回该类型数据的 API 必须遵守为该类型选择的语义。不允许 API 规定或者更改语义。它们必须直到用于该数据的是何种语义，并且遵守该语义。这至少是大型代码库可以实现部分一致性的方法。

以下是基本准则：

  * 声明类型时，必须确定使用的语义。
  * 函数和方法必须遵守给定类型的语义选择。
  * 避免让方法接收器使用与给定类型相对应语义不同的语义。
  * 避免让函数接收或者返回与给定类型相对应的语义不同的数据。
  * 避免修改更定类型的语义。


_这些准则有一些例外，其中最大的例外就是反序列化（Unmarshaling）。反序列化总是要求使用指针语义. 序列化（Marshaling）和反序列化似乎始终是这项规则的例外。_

对于给定类型，你如何决定选择一种语义而不是另一种呢？这些准则会帮你回答这些问题。下面，我们将在某些情况下应用准则：

#### 内置类型

Go 的内置类型表示数值、文本和布尔数据。这些类型应该使用值语义来处理。不要使用指针来共享这些类型，除非你有充分的理由。

例如，看看 `strings` 包中的这些函数声明。

**清单 1**
    
    
    func Replace(s, old, new string, n int) string
    func LastIndex(s, sep string) int
    func ContainsRune(s string, r rune) bool
    

在 API 设计上，这些函数都使用值语义。

#### 引用类型

引用类型表示语言中的切片、map、接口、函数和 channel 类型。这些类型应该使用值语义，因为它们被设计成留在堆栈上以最小化堆的压力。与每次函数调用都会引发潜在的分配相反，它们允许每个函数都拥有其值的一个属于它们自己的副本。这是可能的，因为这些值都包含一个指针，它们在调用之间共享底层数据结构。

不要使用指针来共享这些类型的值，除非你有充分的理由。沿着到 `Unmarshal` 函数的调用堆栈向下共享一个切片或者 map 值是可能是一个例外，例如，看看 `net` 包中声明的这两个类型。

**清单 2**
    
    
    type IP []byte
    type IPMask []byte
    

`IP` 和 `IPMask` 类型都是基于字节切片。这意味着，它们都是引用类型，应该遵循值语义规则。这是一个名为 `Mask` 的方法，它是为 `IP` 类型声明的，接收 `IPMask` 类型的值。

**清单 3**
    
    
    func (ip IP) Mask(mask IPMask) IP {
        if len(mask) == IPv6len && len(ip) == IPv4len && allFF(mask[:12]) {
            mask = mask[12:]
        }
        if len(mask) == IPv4len && len(ip) == IPv6len && bytesEqual(ip[:12], v4InV6Prefix) {
            ip = ip[12:]
        }
        n := len(ip)
        if n != len(mask) {
            return nil
        }
        out := make(IP, n)
        for i := 0; i < n; i++ {
            out[i] = ip[i] & mask[i]
        }
        return out
    }
    

注意，这个方法是一种变异操作，并且使用值语义 API 样式。它使用一个 `IP` 类型的值作为接收器，并且根据传入的 `IPMask` 类型的值来创建一个新的 `IP` 值，并将其副本返回给调用者。该方法遵守这一事实：为引用类型使用值语义。

内置函数 `append`同理。

**清单 4**
    
    
    var data []string
    data = append(data, "string")
    

`append` 函数将值语义用于这种变异操作。将切片值传给 `append`，进行变异后它会返回一个新的切片值。

例外总是反序列化，它要求指针语义。

**清单 5**
    
    
    func (ip *IP) UnmarshalText(text []byte) error {
      	if len(text) == 0 {
      		*ip = nil
      		return nil
      	}
      	s := string(text)
      	x := ParseIP(s)
      	if x == nil {
      		return &ParseError{Type: "IP address", Text: s}
      	}
      	*ip = x
      	return nil
      }
    

`UnmarshalText` 方法实现 `encoding.TextUnmarshaler` 接口。如果不使用指针语义，它将无法正常工作。但这没关系，因为通常可以安全地共享值。在反序列化外，如果指针语义被用于引用类型的话，应该引发一个标志。

#### 用户定义类型

这是你需要做出最多决策的地方。当你声明一个类型的时候，你就必须决定要使用哪种语义了。

如果我要你给 `time` 包编写 API，并且给你下面这种类型的话，你该怎么办？

**清单 6**
    
    
    type Time struct {
        sec  int64
        nsec int32
        loc  *Location
    }
    

你要使用哪种语义？

看看 `Time` 包中这个类型的实现，以及工厂函数 `Now`。

**清单 7**
    
    
    func Now() Time {
      	sec, nsec := now()
      	return Time{sec + unixToInternal, nsec, Local}
      }
    

工厂函数是一个类型最重要的函数之一，因为它告诉你选择了哪种语义。`Now` 函数很清楚地表明了使用了值语义。这个函数创建了一个类型为 `Time` 的值，然后将该值的一个副本返回给调用者。共享 `Time` 值并非必须的，因此它们最终不需要出现在堆中。

另外，看看 `Add` 方法，这是一个变异操作。

**清单 8**
    
    
    func (t Time) Add(d Duration) Time {
      	t.sec += int64(d / 1e9)
      	nsec := t.nsec + int32(d%1e9)
      	if nsec >= 1e9 {
      		t.sec++
      		nsec -= 1e9
      	} else if nsec < 0 {
      		t.sec--
      		nsec += 1e9
      	}
      	t.nsec = nsec
      	return t
      }
    

再次，你可以看到，`Add` 方法遵守了该类型选择的语义。`Add` 方法使用值接收器来操作自己 `Time` 值的副本，其中，`Time` 值的副本被用来进行调用。接着，它改变了自己的副本，并且将 `Time` 值的新副本返回给调用者。

这是一个接收 `Time` 值的函数：

**清单 9**
    
    
    func div(t Time, d Duration) (qmod2 int, r Duration) {
    

再次，使用值语来接收 `Time` 类型的值。`Time` API 仅将指针语义用于 `Unmarshal` 相关的函数：

**清单 10**
    
    
    func (t *Time) UnmarshalBinary(data []byte) error {
    func (t *Time) GobDecode(data []byte) error {
    func (t *Time) UnmarshalJSON(data []byte) error {
    func (t *Time) UnmarshalText(data []byte) error {
    

大多时候，使用值语义的能力是有限的。在函数间传递数据时对其进行拷贝是不正确或者不合理的。数据更改需要隔离为单个值并共享。这是需要指针语义的时候。如果你不是百分百确信拷贝是合理或者正确的，那么使用指针语义.

看看 `os` 包中 `File` 类型的工厂函数。

**清单 11**
    
    
    func Open(name string) (file *File, err error) {
        return OpenFile(name, O_RDONLY, 0)
    }
    

`Open` 函数返回一个类型为 `File` 的指针。这意味着，你应该使用指针语义，并且总是共享 `File` 值。将语义从指针更改为值可能会破坏你的程序。当函数与你共享值的时候，你应该假设你不能复制该指针指向的值。如果你复制了，那么结果将是不确定的。

看看更多的 API，你会看到指针语义的一致使用。

**清单 12**
    
    
    func (f *File) Chdir() error {
        if f == nil {
            return ErrInvalid
        }
        if e := syscall.Fchdir(f.fd); e != nil {
            return &PathError{"chdir", f.name, e}
        }
        return nil
    }
    

`Chdir` 方法使用指针语义，即使 `File` 值永不被改变。这个方法必须遵守该类型的语义约定。

**清单 13**
    
    
    func epipecheck(file *File, e error) {
        if e == syscall.EPIPE {
            if atomic.AddInt32(&file.nepipe, 1) >= 10 {
                sigpipe()
            }
        } else {
            atomic.StoreInt32(&file.nepipe, 0)
        }
    }
    

这是一个名为 `epipecheck` 的函数，它使用指针语义来接收 `File` 值。再次，注意类型为 `File` 的直到对指针语义的一致使用。

### 总结

在代码评审时，我总会查找值/指针语义的一致使用。它可以帮助你在时间的推移中仍然保持代码的一致和可预测。它还使得每个人都可以维护一个清晰且一致的代码思维模型。随着代码库和团队的壮大，值/指针语义的一致使用变得更为重要。

Go 的惊人之处在于，指针和值语义之间的选择不仅仅局限于接收器和函数参数的声明。从 `for range` 的工作方式，到接口、函数值和切片的机制，无所不包。在以后的文章中，我将说明在语言的这些不同部分中如何显示值/指针语义。
