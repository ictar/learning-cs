原文：[Garbage Collection In Go : Part I - Semantics](https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html)

---



### 前言

这是一个包含三个部分的系列文，它将向你提供对 Go 垃圾回收器背后对机制和语义对理解。这是第一篇。本文着重于回收器语义的基础知识。

该序列文三个部分对索引： 
1) [Go 垃圾回收（第一部分）：语义](https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html)  
2) [Go 垃圾回收（第二部分）：GC 跟踪](https://www.ardanlabs.com/blog/2019/05/garbage-collection-in-go-part2-gctraces.html)  
3) [Go 垃圾回收（第三部分）：GC Pacing](https://www.ardanlabs.com/blog/2019/07/garbage-collection-in-go-part3-gcpacing.html)

### 介绍

垃圾回收器负责跟踪堆内存分配，释放不再需要的内存分配，并保留仍在使用的内存分配。语言决定这种行为的方式是很复杂的，但对于应用开发人员来说，要构建软件，并不一定要了解这些细节。此外，随着语言 VM 或者运行时的不同发行版本，这些系统的实现总是在变化和发展。对于应用开发人员来说，重要的是，对以下内容要有一个良好的概念：所使用语言的垃圾回收器的行为方式，以及如何理解该行为而无需关心其实现。

从 1.12 版本开始，Go 编程语言使用非世代并发的三色标记和清除回收器。如果你想直观地看到一个标记清除回收器是如何工作的，那么 Ken Fox 写了这篇很棒的[文章](https://spin.atomicobject.com/2014/09/03/visualizing-garbage-collection-algorithms)，里面提供了一个动画。在 Go 的每个发行版本中，Go 回收器的实现都发生了变化和演进。因此，一旦发布了下一个版本，任何谈及有关实现细节的文章都不再准确。

综上所述，本文中，我将进行的建模将不会关注实际的实现细节。建模将着重于你将体验到的行为，以及未来几年应该期望看到的行为。在这篇文章中，我将和你分享回收器的行为，并说明如何理解这些行为，不管当前的实现方式是怎样的或者将来的实现方式会如何变化。这将让你成为更好的 Go 开发者。

_注意：你可以在这里读到更多关于[垃圾回收器](https://github.com/ardanlabs/gotraining/tree/master/reading#garbage-collection)以及 Go 的实际回收器的信息。_

### 堆并非容器

我永远不会把堆称为可以存储或者释放值的容器。重要的是要了解，并没有定义“堆”的线性存储空间。考虑到保留给应用在进程空间中使用的任何内存都可用于堆内存分配。任何给定的堆内存分配虚拟存储或者物理存储的位置与我们的模型无关。这种了解将帮助你更好地了解垃圾回收器的工作方式。

### 收集器行为

回收开始时，回收器将经历三个工作阶段。其中两个阶段造成了STW（Stop The World）延迟，而另一个阶段则会造成降低应用吞吐量的延迟。这三个阶段是：

  * 标记设置 - STW
  * 标记 - 并发
  * 标记终止 - STW



下面是每个阶段的细分。

**标记设置 - STW**

开始回收时，必须执行的第一件事情是打开写屏障（Write Barrier）。写屏障的目的是，允许回收器在回收期间保持堆上数据的完整性，因为回收器和应用 goroutine 会并发运行。

为了打开写屏障，必须停止运行应用的每个 goroutine。这种操作通常很快，平均在 10 到 30 微秒内。也就是说，和应用 goroutine 正常运行时一样长。

_注意：为了更好地理解这些调度器图，请务必阅读关于 [Go 调度器](https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html)的系列文。_

**图 1**  
![](https://www.ardanlabs.com/images/goinggo/100_figure1.png)

图 1 显示了在开始回收前运行的 4 个应用 goroutine。这 4 个 goroutine 的每一个都必须停止。唯一做到这一点的方法是让回收器监视并等待每个 goroutine 进行函数调用。函数调用确保 goroutine 是在安全的地方被停止的。如果这些 goroutine 中有一个没有进行函数调用，但其他的 goroutine 都进行了函数调用，会发生什么呢？

**图 2**  
![](https://www.ardanlabs.com/images/goinggo/100_figure2.png)

图 2 显示了一个实际的问题。回收操作要等到 P4 上运行的 goroutine 停止后才开始，但由于这个 goroutine 正处在进行一些数学运算的[紧密循环](https://github.com/golang/go/issues/10958)中，所以它无法停止。

**清单 1**
    
    
    01 func add(numbers []int) int {
    02     var v int
    03     for _, n := range numbers {
    04         v += n
    05     }
    06     return v
    07 }
    

清单 1 显示了运行在 P4 上的 Goroutine 正在执行的代码。根据切片的大小，这个 Goroutine 可能会运行一段不合理的时间，并且没有机会停止。这类型的代码可能会阻滞回收的开始。更糟糕的是，回收器等待期间，其他 P 都无法为其他 goroutine 提供服务。因此，至关重要的一点是，goroutine 在合理的时间范围内进行函数调用。

_注意：这是语言团队希望通过在调度器中添加[抢占式](https://github.com/golang/go/issues/24543)技术，在 1.14 中纠正的问题。_

**标记 - 并发**

一旦打开写屏障，回收器将从标记阶段开始。回收器要做的第一件事情就是为自己占用 25% 的可用 CPU 容量。回收器使用 Goroutine 进行回收工作，并且需要和应用 Goroutine 使用相同的 P 和 M。这意味着，对于我们这 4 线程 Go 程序，其中一个完整的 P 将被专门用于回收工作。

**图 3**  
![](https://www.ardanlabs.com/images/goinggo/100_figure3.png)

图 3 显示了回收期间回收器是如何为自己获取 P1 的。现在，回收器可以开始标记阶段了。标记阶段包括标记堆内存中仍在使用的值。这项工作首先检查所有现有的 goroutine 的堆栈，查找指向堆内存的根指针。然后，回收器从这些根指针开始遍历堆内存图。在 P1 进行标记工作的时候，可以同时在 P2、P3 和 P4 上继续并发执行应用指令。这意味着，回收器的影响已经最小化到当前 CPU 容量的 25%。

我希望这样就完事了，但事实并非如此。如果在回收期间发现，在堆内存达到其使用上限的之前，P1 上专用于 GC 的 Goroutine 还无法完成标记工作的话，该怎么办？如果那三个执行应用指令的 Goroutine 之一就是回收器无法及时完成工作的原因，又要怎么办呢？在这种情况下，必须放慢新的分配速度，特别是放慢来自那个 Goroutine 的分配请求。

如果回收器决定需要放慢分配速度，它将征用应用 Goroutine 来协助标记工作。这称为标记辅助。任何应用 Goroutine 处于标记辅助的时间与它添加到堆内存中的数据量成正比。标记辅助的一个正面影响是，它有助于快速完成回收。

**图 4**  
![](https://www.ardanlabs.com/images/goinggo/100_figure4.png)

图 4 显示了 P3 上运行的应用 Goroutine 现在如何进行标记辅助，并协助回收工作。希望其他应用 Goroutine 也不需要参与。进行大量分配的应用可能会看到，在回收期间，大多数正在运行的 Goroutine 都会进行少量的标记辅助工作。

回收器的一个目标是消除对标记辅助的需求。如果任意给定的回收最终需要大量的标记辅助，那么回收器可以更早开始下一次的垃圾回收。这样做是为了减少下一次回收所需的“标记辅助”量。

**标记终止 - STW**

一旦完成了标记工作，下一个阶段就是标记终止。此时，会关闭写屏障，然后执行各种清理任务，然后计算下一次回收目标。那些在标记阶段还处于紧密循环中的 Goroutine 也会导致标记终止 STW 延迟被延长。

**图 5**  
![](https://www.ardanlabs.com/images/goinggo/100_figure5.png)

图 5 显示了在标记终止阶段完成时如何停止所有的 Goroutine。这项操作通常平均花费 60 到 90 微秒。该阶段可以在没有 STW 的情况下完成，但是通过使用 STW，代码会更简单，而且不使用 STW 时带来的好处并不值得为此增加的代码复杂度。

一旦完成了回收，每一个 P 就可以再次为应用所用，然后应用将恢复正常运行。

**图 6**  
![](https://www.ardanlabs.com/images/goinggo/100_figure6.png)

图 6 显示了一旦完成回收，所有可用的 P 现在如何再次处理应用指令。应用已经恢复到回收开始之前的工作状态。

**清除 - 并发**

回收完成后还会发生另一种活动，也就是“清除”。清除是指回收那些与堆内存中未标记为使用中的值相关联的内存。当应用 Goroutine 试图在堆内存中分配新的值的时候，将会发生此操作。清除的延迟增加了在堆内存中进行分配的成本，并且与垃圾回收相关的任何延迟均不相关。

下面是我机器上的跟踪示例，其中，有 12 个可用于执行 Goroutine 的硬件线程。

**图 7**  
![](https://www.ardanlabs.com/images/goinggo/100_figure7.png)

图 7 显示了跟踪的部分快照。你可以看到在此回收期间（将视线保持在顶部的蓝色 GC 行上），十二个 P 中的三个 P 被专门用于 GC。你可以看到，在此期间，Goroutine 2450、1978 和 2696 正在执行标记辅助工作，而不是应用指令。在收集的最后时刻，只有一个 P 专门用于 GC，并最终执行 STW（标记终止）工作。

收集完成后，应用将恢复全速运行状态。除了在这些 Goroutine 下面可以看到许多玫瑰色的行。

**图 8**  
![](https://www.ardanlabs.com/images/goinggo/100_figure8.png)

图 8 表明，这些玫瑰色的行表示 Goroutine 正在进行清除工作，而不是应用自身的工作。此时，Goroutine 正试图在堆内存中分配新的值。

**图 9**  
![](https://www.ardanlabs.com/images/goinggo/100_figure9.png)

图 9 显示了在清除过程总，其中一个 Goroutine 的堆栈跟踪结尾。调用 `runtime.mallocgc` 来在堆内存中分配新值。调用 `runtime.(*mcache).nextFree` 会导致清除。一旦堆内存中不再有要回收的分配，就不会在看到 `nextFree` 调用。

刚刚描述的回收行为仅在回收已经启动并且正在运行的时候才会发生。其中，GC 百分比配置项在决定何时开始回收起着重要作用。

### GC 百分比

运行时中有一个配置项叫做 GC 百分比（GC Percentage），默认情况下值为 100。该值表示在必须开始下一次回收之前，可以分配新的堆内存的比例。将 GC 百分比设置为 100 表示，根据一次回收完成后标记为活动的堆内存量，下一次回收必须在对堆内存进行 100%（译注：也就是在使用堆内存量的 100%） 新分配时或之前开始。

例如，假设一个回收结束时只有 2MB 大小对堆内存仍在使用。

_注意：本文中对堆内存示意图并不代表使用 Go 时的真实概要。Go 中的堆内存通常是零散且混乱的，因此你无法像所展示的图像那样将其清晰地分开。这些图提供了一种更易于理解的可视化堆内存的方式，这种方式对于你将遇到的行为是准确的。_

**图 10**  
![](https://www.ardanlabs.com/images/goinggo/100_figure10.png)

图 10 显示了最后一次回收结束后正在使用的 2MB 堆内存。由于 GC 百分比设置为 100%，因此下一次回收需要在增加 2MB 以上的堆内存时或之前开始。

**图 11**  
![](https://www.ardanlabs.com/images/goinggo/100_figure11.png)

图 11 显示了另外 2MB 堆内存正在使用中。这将触发回收。查看所有这些操作的一种方式是，为发生的每一次回收生成 GC 跟踪。

### GC 跟踪

在运行任意 Go 应用时，在环境变量 `GODEBUG` 中包含 `gctrace=1` 选项就可以生成 GC 跟踪。每次进行回收时，运行时将会把 GC 跟踪信息写到 `stderr`（译注：标准错误输出）。

**清单 2**
    
    
    GODEBUG=gctrace=1 ./app
    
    gc 1405 @6.068s 11%: 0.058+1.2+0.083 ms clock, 0.70+2.5/1.5/0+0.99 ms cpu, 7->11->6 MB, 10 MB goal, 12 P
    
    gc 1406 @6.070s 11%: 0.051+1.8+0.076 ms clock, 0.61+2.0/2.5/0+0.91 ms cpu, 8->11->6 MB, 13 MB goal, 12 P
    
    gc 1407 @6.073s 11%: 0.052+1.8+0.20 ms clock, 0.62+1.5/2.2/0+2.4 ms cpu, 8->14->8 MB, 13 MB goal, 12 P
    

清单 2 显示了如何使用 `GODEBUG` 变量来生成 GC 跟踪。清单还显示了运行中的 Go 应用生成的 3 条跟踪。

通过审查清单中的第一条 GC 跟踪行，可以深入了解 GC 跟踪中每个值的含义。

**清单 3**
    
    
    gc 1405 @6.068s 11%: 0.058+1.2+0.083 ms clock, 0.70+2.5/1.5/0+0.99 ms cpu, 7->11->6 MB, 10 MB goal, 12 P
    
    // 常规
    gc 1404     : 自程序启动后的第 1404 次 GC 运行
    @6.068s     : 自程序启动后过去了 6 秒
    11%         : 目前已经在 GC 上花费了 11% 个可用 CPU
    
    // Wall-Clock
    0.058ms     : STW        : 标记开始       - 写屏障打开
    1.2ms       : Concurrent : 标记
    0.083ms     : STW        : 标记终止 - 写屏障关闭，然后清理
    
    // CPU 时间
    0.70ms      : STW        : 标记开始
    2.5ms       : Concurrent : 标记 - 辅助时间（执行 GC 与分配一致）
    1.5ms       : Concurrent : 标记 - 后台 GC 时间
    0ms         : Concurrent : 标记 - 空闲 GC 时间
    0.99ms      : STW        : 标记终止
    
    // 内存
    7MB         : 标记开始前使用中的堆内存
    11MB        : 标记结束后使用中的堆内存
    6MB         : 标记结束后被标记为活跃的堆内存
    10MB        : 标记结束后使用中的堆内存的回收目标
    
    // 线程
    12P         : 用来运行 Goroutine 的逻辑处理器或者线程数
    

清单 3 显示了来自第一条 GC 跟踪行的实际数字，根据值含义进行细分。我最终会讨论其中大部分值，但是现在，我只会关注跟踪 1405 中 GC 跟踪的内存部分。

**图 12**  
![](https://www.ardanlabs.com/images/goinggo/100_figure12.png)

**清单 4**
    
    // 内存
    7MB         : 标记开始前使用中的堆内存
    11MB        : 标记结束后使用中的堆内存
    6MB         : 标记结束后被标记为活跃的堆内存
    10MB        : 标记结束后使用中的堆内存的回收目标    

清单 4 中的这个 GC 跟踪行是在告诉你，在标记工作开始之前，正在使用的堆内存量是 7MB。当标记完成时，正在使用的堆内存量达到 11MB。这意味着，在回收期间发生了另外 4MB 的堆内存分配。标记工作完成后标记为活动的堆内存为 6MB。这意味着在下一次回收需要启动之前，应用可以将正在使用的堆内存量增加到 12MB（6MB 活动堆大小的 100%）。

你可以看到，回收器与其回收目标相差了 1MB。标记工作完成后正在使用的堆内存量是 11MB，而不是 10MB。这没关系，因为这个目标是根据当前正在使用的堆内存量、标记为活动的堆内存量、以及回收进行时将发生的其他分配的计时计算得出的。在这种情况下，应用进行一些操作，这些操作需要使用比预期更多堆内存。

如果你看一下下一行 GC 跟踪（1406），你将看到 2ms 内发生了怎样的变化。

**图 13**  
![](https://www.ardanlabs.com/images/goinggo/100_figure13.png)

**清单 5**
    
    
    gc 1406 @6.070s 11%: 0.051+1.8+0.076 ms clock, 0.61+2.0/2.5/0+0.91 ms cpu, 8->11->6 MB, 13 MB goal, 12 P

    // 内存
    8MB         : 标记开始前使用中的堆内存
    11MB        : 标记结束后使用中的堆内存
    6MB         : 标记结束后被标记为活跃的堆内存
    13MB        : 标记结束后使用中的堆内存的回收目标 
    

清单 5 显示了，在上一次回收启动的 2ms 后，本次回收启动（6.068s vs 6.070s），即使此时正在使用的堆内存仅达到允许的 12MB 里的 8MB。需要注意的重要一点是，如果回收器认为它最好尽早开始回收工作，那么它会提前。在这种情况下，它可能会提前启动，因为应用分配过多，而回收器希望减少此次回收期间的标记辅助延迟时间。

还有两点需要注意，这一次，回收器保持在其目标之内。标记结束后正在使用的堆内存量是 11MB，而不是 13MB，少了 2MB。标记结束后标记为活跃的堆内存量相同，为 6MB。

作为旁注，你可以通过添加 `gcpacertrace=1` 标志，从而从 GC 跟踪中获取更多详情。这会让回收器打印有关并发 pacer 内部状态的信息。

**清单 6**
    
    
    $ export GODEBUG=gctrace=1,gcpacertrace=1 ./app
    
    Sample output:
    gc 5 @0.071s 0%: 0.018+0.46+0.071 ms clock, 0.14+0/0.38/0.14+0.56 ms cpu, 29->29->29 MB, 30 MB goal, 8 P
    
    pacer: sweep done at heap size 29MB; allocated 0MB of spans; swept 3752 pages at +6.183550e-004 pages/byte
    
    pacer: assist ratio=+1.232155e+000 (scan 1 MB in 70->71 MB) workers=2+0
    
    pacer: H_m_prev=30488736 h_t=+2.334071e-001 H_T=37605024 h_a=+1.409842e+000 H_a=73473040 h_g=+1.000000e+000 H_g=60977472 u_a=+2.500000e-001 u_g=+2.500000e-001 W_a=308200 goalΔ=+7.665929e-001 actualΔ=+1.176435e+000 u_a/u_g=+1.000000e+000
    

运行 GC 跟踪可以告诉你很多关于应用运行情况和回收器运行节奏的信息。回收器的运行节奏在回收过程中起着重要作用。

### 回收节奏（pacing）

回收器有一个 pacing 算法，用于确定一次回收的开始时间。该算法取决于一个反馈循环，回收器使用该循环来收集有关正在运行的应用和应用对堆施加的压力的信息。压力可以被定义为在给定时间内，应用分配堆内存的速度。正是这种压力决定了回收器需要运行的节奏。

在回收器开始进行回收之前，它会计算完成此次回收预期花费的时间。然后，一旦进行回收，将会对正在运行的程序造成延迟，这将减慢应用的工作速度。每一次回收都会增加应用的整体延迟。

一个误解是认为放慢回收器节奏是提高性能的一种方式。这个想法是，如果可以延迟下一次回收的启动，那么你就能延迟它将带来延迟。减小回收器的延迟并不会减慢回收器节奏。

你可以决定将 GC 百分比修改为大于 100 的值。这将提高必须开始下一次回收之前可以分配的堆内存量。这可能会导致回收节奏变慢。不要想着这样做。

**图 14**  
![](https://www.ardanlabs.com/images/goinggo/100_figure14.png)

图 14 显示了修改 GC 百分比将如何改变下一次回收必须开始之前允许分配的堆内存量。你可以直观地看到，在回收器等待更多的堆内存投入使用时，它是如何放慢速度的。

试图直接影响回收节奏与减小回收器的延迟没有半毛钱关系。实际上，这是为了让每次回收之间或者回收期间可以完成更多的工作。通过减少任何工作添加到堆内存中的分配量或者分配次数，你可以影响到这一点。

_注意：这个想法也是用尽可能小的堆来实现所需的吞吐量。请记住，在云环境中运行时，最小化堆内存等资源的使用是非常重要的。_

**图 15**  
![](https://www.ardanlabs.com/images/goinggo/100_figure15.png)

清单 15 显示了一个正在运行的 Go 应用的一些统计信息，这个 Go 应用将会在本系列的下一部分用到。蓝色版本显示了当应用处理 10k 请求时，应用没有进行任何优化的情况下的统计信息。绿色版本显示了应用查找并删除 4.48GB 无用内存分配后，处理同样 10k 请求时的统计信息。

看一下这两个版本的平均回收节奏（2.08ms vs 1.96ms）。它们几乎一样，大约为 2.0ms。这两个版本之间的根本区别是每次回收之间完成的工作量。应用从每次回收处理 3.98 个请求到处理 7.13 个请求。也就是说，在相同的回收节奏下，完成的工作量提高了 79.1%。如你所见，回收并没有随着分配的减少而变慢，而是保持不变。胜利来源于在每次回收之间（或者期间）完成更多的工作。

调整回收节奏以推迟延迟成本并不是提高应用性能的方法。而是减少回收器需要运行的时间，而这又将减少回收造成的延迟成本。已经解释了回收器造成的延迟成本，但为了清晰起见，让我来再次总结下。

### 回收器延迟成本

每次回收对正在运行的应用造成的延迟有两种。第一种是窃取 CPU 容量。CPU 容量被窃取意味着应用在回收过程中并未以全速运行。应用的 Goroutine 现在正与回收器的 Goroutine 共享 P，或者帮助回收（标记辅助）。

**图 16**  
![](https://www.ardanlabs.com/images/goinggo/100_figure16.png)

图 16 显示了应用是如何仅使用其 CPU 容量的 75% 进行应用自身的工作的。这是因为回收器自己占用了 P1.大多数回收都将会是这样。

**图 17**  
![](https://www.ardanlabs.com/images/goinggo/100_figure17.png)

图 17 显示了此时此刻（通常只有几微秒）应用是如何仅使用其 CPU 容量的一半进行自身工作的。这是因为 P3 上的 goroutine 正在进行标记辅助，并且回收器自身占用了 P1。

_注意：在每 MB 大小的活跃堆上，标记通常花费 4 CPU-毫秒（例如，将单位为 MB 的活跃堆大小除以 0.25 与 CPU 数目的乘积，就可以估算标记阶段运行了多少毫秒）。标记实际上的运行速度约为 1 MB/ms，但只有四分之一的 CPU。_

造成的第二种延迟是回收期间的 STW 延迟量。STW 时间是指没有应用 Goroutine 执行任何应用工作的时间。应用实际上已经停止了。

**图 18**  
![](https://www.ardanlabs.com/images/goinggo/100_figure18.png)

图 18 显示了 STW 延迟，其中，所有的 Goroutine 都停止了。每次回收这种事情都会发生两次。如果你的应用运行状态良好，那么对于大多数的回收来说，回收器应该能够将整个 STW 时间保持在不超过 100 微秒。

现在，你知道了回收器的不同阶段，如何标记内存大小，回收节奏的工作方式，以及回收器对正在运行的应用造成的不同类型的延迟。有了这些知识，就可以最终回答你可以如何减小回收器的延迟这个问题了。

### 减小回收器的延迟

减小回收器的延迟就是减小堆内存的压力。请记住，压力可以被定义为应用在给定时间内的堆内存分配速度。当压力减小时，回收器造成的延迟将减小。是 GC 延迟拖慢了你的应用。

减少 GC 延迟的方法是识别并删除应用中不必要的分配。这样做将以多种方式帮助回收器。

帮助回收器：

  * 保持尽可能小的堆。
  * 找到最佳的一致回收节奏。
  * 每次回收都保持在目标之内。
  * 最小化每次收集、STW 和标记辅助的持续时间。



这些都有助于减少回收器堆正在运行的应用造成的延迟。这将提高应用性能和吞吐量。回收节奏与其无关。你还可以做其他事情来帮助做出更好的工程决策，从而减少堆的压力。

**了解你的应用正在执行的工作负载的性质**  
了解工作负载意味着确保你用来完成工作的 goroutine 数目合理。计算密集型和 IO 密集型的负载是不一样的，因此需要不同的工程决策。

<https://www.ardanlabs.com/blog/2018/12/scheduling-in-go-part3.html>

**了解定义的数据，以及它们在应用中的传递方式**  
了解数据意味着了解要解决的问题。数据语义一致性是维护数据完整性的关键部分，它让你可以（通过阅读代码）知道什么时候你选择了在堆上而不是栈上进行分配。

<https://www.ardanlabs.com/blog/2017/06/design-philosophy-on-data-and-semantics.html>

### 总结

如果你花时间在专注减少分配，那么你就是在以一名 Go 开发者的身份，尽一切努力减少垃圾回收器的延迟。你不会编写零分配的应用，因此，认识有效分配（有利于应用的分配）和无效分配（不利于应用的分配）之间的区别很重要。然后，相信垃圾回收器会保持堆健康，并让你的应用一直运行。

使用垃圾回收器是一项不错的权衡。我将承担垃圾回收的成本，因此，我就没有内存管理的负担。Go 让开发人员可以提高工作效率，同时仍然编写足够快的应用。垃圾回收器是实现这一目标的重要组成部分。在下一篇文章中，我将向你展示一个示例 web 应用，以及如何使用工具，在实战中查看所有这些操作。
