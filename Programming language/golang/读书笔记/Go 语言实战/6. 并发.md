目录
=================

   * [并发](#并发)
      * [并发与并行](#并发与并行)
         * [并发（concurrency） V.S 并行（parallelism）](#并发concurrency-vs-并行parallelism)
         * [MPG 调度模型](#mpg-调度模型)
            * [并行运行 goroutine](#并行运行-goroutine)
      * [goroutine](#goroutine)
      * [竞争状态](#竞争状态)
         * [-race](#-race)
      * [锁住共享资源](#锁住共享资源)
         * [原子函数](#原子函数)
         * [互斥锁](#互斥锁)
      * [通道](#通道)
         * [无缓冲的通道](#无缓冲的通道)
         * [有缓冲的通道](#有缓冲的通道)


# 并发
Go语言的并发同步模型来自一个叫作**通信顺序进程**（Communicating Sequential Processes，CSP）的范型（paradigm）。CSP是一种消息传递模型，通过在goroutine之间传递数据来传递消息，而不是对数据进行加锁来实现同步访问。用于在goroutine之间同步和传递数据的关键数据类型叫作**通道**（channel）。

## 并发与并行
操作系统会在物理处理器上调度线程来运行，而 Go 语言的运行时会在逻辑处理器上调度goroutine来运行。每个逻辑处理器都分别绑定到单个操作系统线程。

### 并发（concurrency） V.S 并行（parallelism）
并行是让不同的代码片段同时在不同的物理处理器上执行。并行的关键是同时做很多事情，而并发是指同时管理很多事情，这些事情可能只做了一半就被暂停去做别的事情了。

### MPG 调度模型
如果创建一个goroutine并准备运行：
1. 这个goroutine就会被放到调度器的全局运行队列中。
2. 调度器就将全局运行队列中的goroutine分配给一个逻辑处理器，并放到这个逻辑处理器对应的本地运行队列中。
3. 本地运行队列中的goroutine会一直等待直到自己被分配的逻辑处理器执行。

当正在运行的goroutine需要执行一个阻塞的系统调用（如打开一个文件）时：
1. 线程和goroutine会从逻辑处理器上分离，
2. 该线程会继续阻塞，等待系统调用的返回。
3. 与此同时，这个逻辑处理器就失去了用来运行的线程。
   1. 调度器会创建一个新线程，并将其绑定到该逻辑处理器上。
   2. 之后，调度器会从本地运行队列里选择另一个goroutine来运行。
4. 一旦被阻塞的系统调用执行完成并返回，对应的goroutine会放回到本地运行队列，而之前的线程会保存好，以便之后可以继续使用。

如果一个goroutine需要做一个网络I/O调用，流程上会有些不一样。在这种情况下：
1. goroutine会和逻辑处理器分离，并移到集成了网络轮询器的运行时。
2. 一旦该轮询器指示某个网络读或者写操作已经就绪，对应的goroutine就会重新分配到逻辑处理器上来完成操作。

调度器对可以创建的逻辑处理器的数量没有限制，但语言运行时默认限制每个程序最多创建 10000个线程。这个限制值可以通过调用 `runtime/debug` 包的 `SetMaxThreads` 方法来更改。如果程序试图使用更多的线程，就会崩溃。

#### 并行运行 goroutine
如果希望让goroutine并行，必须使用多于一个逻辑处理器。当有多个逻辑处理器时：调度器会将goroutine平等分配到每个逻辑处理器上。这会让goroutine在不同的线程上运行。不过要想真的实现并行的效果，用户需要让自己的程序运行在有多个物理处理器的机器上。

## goroutine
```golang
go fn()
```

* `runtime` 包的 `GOMAXPROCS` 函数：允许程序更改调度器可以使用的逻辑处理器的数量。
  * `runtime.NumCPU()` 函数：返回可以使用的物理处理器的数量。
  * 如果不想在代码里做这个调用，也可以通过修改和这个函数名字一样的环境变量的值来更改逻辑处理器的数量。
  * 注意：使用多个逻辑处理器并不意味着性能更好。在修改任何语言运行时配置参数的时候，都需要配合基准测试来评估程序的运行效果。
* `sync.WaitGroup`：一个计数信号量，可以用来记录并维护运行的goroutine。
  * 如果WaitGroup的值大于0，`Wait` 方法就会阻塞
* `runtime.Gosched` 函数：用于将goroutine从当前线程退出，给其他goroutine运行的机会。

当goroutine占用时间过长时，调度器会停止当前正运行的goroutine，并给其他可运行的goroutine运行的机会。

> 注意：只有在有多个逻辑处理器且可以同时让每个goroutine运行在一个可用的物理处理器上的时候，goroutine才会并行运行。


## 竞争状态
如果两个或者多个goroutine在没有互相同步的情况下，访问某个共享的资源，并试图同时读和写这个资源，就处于相互竞争的状态，这种情况被称作**竞争状态（race candition）**。

对一个共享资源的读和写操作必须是原子化的，换句话说，同一时刻只能有一个goroutine对共享资源进行读和写操作。

一种修正代码、消除竞争状态的办法是，使用Go语言提供的锁机制，来锁住共享资源，从而保证goroutine的同步状态。

### `-race`
Go语言有一个特别的工具，可以在代码里检测竞争状态。

```sh
# 用竞争检测器标志来编译程序
$ go build -race
```

## 锁住共享资源

### 原子函数
原子函数能够以很底层的加锁机制来同步访问整型变量和指针。
```golang
import "sync/atomic"
```
* `atomic.AddInt64()` 函数：同步整型值的加法，方法是强制同一时刻只能有一个goroutine运行并完成这个加法操作。
* `atomic.LoadInt64()` 函数：提供了一种安全地读一个整型值的方式
* `atomic.StoreInt64()` 函数：提供了一种安全地写一个整型值的方式

### 互斥锁
互斥锁 `sync.Mutex` 用于在代码上创建一个临界区，保证同一时间只有一个goroutine可以执行这个临界区代码。

## 通道
在Go语言里，你不仅可以使用原子函数和互斥锁来保证对共享资源的安全访问以及消除竞争状态，还可以使用通道，通过发送和接收需要共享的资源，在goroutine之间做同步。

声明通道时，需要指定将要被共享的数据的类型。可以通过通道共享内置类型、命名类型、结构类型和引用类型的值或者指针。
```golang
var ch chan T
// 类型为 T 的无缓冲通道
ch = make(chan T)
// 类型为 T 的带大小为 size 的缓冲的通道
ch = make(chan T, size)
```

向通道发送值或者指针，以及从通道接收值或者指针都需要用到 `<-` 操作符。
```golang
// 发送
ch <- val
// 接收
val = <-ch
```

### 无缓冲的通道
无缓冲的通道（unbuffered channel）是指在接收前没有能力保存任何值的通道。
* 这种类型的通道要求发送goroutine和接收goroutine同时准备好，才能完成发送和接收操作。
* 如果两个goroutine没有同时准备好，通道会导致先执行发送或接收操作的goroutine阻塞等待。
* 这种对通道进行发送和接收的交互行为本身就是同步的。其中任意一个操作都无法离开另一个操作单独存在。

### 有缓冲的通道
有缓冲的通道（buffered channel）是一种在被接收前能存储一个或者多个值的通道。
* 这种类型的通道并不强制要求goroutine之间必须同时完成发送和接收。
* 通道会阻塞发送和接收动作的条件也会不同。
  * 只有在通道中没有要接收的值时，接收动作才会阻塞。
  * 只有在通道没有可用缓冲区容纳被发送的值时，发送动作才会阻塞。
* 有缓冲的通道和无缓冲的通道之间的一个很大的不同：
  * 无缓冲的通道保证进行发送和接收的goroutine会在同一时间进行数据交换；
  * 有缓冲的通道没有这种保证。

当通道关闭后，goroutine依旧可以从通道接收数据，但是不能再向通道里发送数据。能够从已经关闭的通道接收数据这一点非常重要，因为这**允许通道关闭后依旧能取出其中缓冲的全部值，而不会有数据丢失**。**从一个已经关闭且没有数据的通道里获取数据，总会立刻返回，并返回一个通道类型的零值**。如果在获取通道时还加入了可选的标志，就能得到通道的状态信息。