# `main` 函数概览与 package 声明

```go
// main.go
package main // 包声明

// func = 方法关键字
func main() { // 使用小括号和大括号来组织代码
	println("Hello, Go!") // 输出语句
}
```

## `main` 函数
要点：
- 无参数，无返回值
- `main` 方法必须要在 `main` 包里
- `go run main.go` 即可执行
    * 如果文件名不是 `main.go`，则需要`go build`得到可执行文件，然后直接运行生成的可执行问价。

## 包
### 声明：`package {packagename}`
要点：
- 包名是字母和下划线的组合，可以和文件夹不同名，但是同一个文件夹下的声明必须一致

### 包引入
```go

import "unicode/utf8"

import (
    "fmt"
    "net/http"
    _ "strings" // 匿名引用
)
```
注意：
- 如果一个引入的包未被使用，则会报错
- 如果不使用包，但是需要调用到包的初始化方法 `init()`，则可以使用**匿名引用**来达到目的。

# 基础类型

- golang **不会做隐式类型转换**，类型不同无法通过编译。

## 数值类型：bool / int / uint / float

明确标注了长度、有无符号

### bool 类型：true / false

### int 类型：int8 / int16 / int32 / int64 / int

### uint 类型：uint8 / uint16 / uint32 / uint64 / uint

### float 类型：float32 / float64

## byte 类型
byte，字节，本质是 uint8，对应的操作包在 `bytes` 上。
```go
type byte = uint8
```

## 字符串（string）

```go
import (
	"unicode/utf8"
)

func main() {
	println(len("你好")) // 6
	println(utf8.RuneCountInString("你好")) // 2
	println(utf8.RuneCountInString("你好ab")) // 4
}
```
- 如果是双引号引起来，则内部双引号需要使用“\”转义；如果是用“\`” 引起来（适用于大段字符串，需要换行等），则内部 “`” 需要“\”转义
- 长度
  - 字节长度：编码无关，用 `len(str)` 获取
  - 字符数量：编码相关，用编码库来计算，例如使用 `utf8.RuneCountInString(str)`
- 拼接：直接使用”+“即可。注意，string 只能和 string 拼接

### `strings`包
主要方法：
- 查找和替换
- 大小写转换
- 子字符串相关
- 相等

## rune 类型

rune 不是 byte，它本质上是 int32（一个 rune 四个字节）。它接近一般语言的 char 或者 character 的概念
```go
type rune = int32
```

# 变量和常量

## 变量声明
## 一般情况：`var name type = value`
```go
// 全局变量首字母大写，全局可访问
var Global = "全局变量"

// 首字母小写，只能在这个包中使用，其子包不能用
var local = "包变量"

var (
	First  string = "abc"
	second int32  = 3
)

func main() {
	// type 可省略，比如这里的 int。因为 golang 支持类型推断
	var a int = 11
	println(a)

	// 比如这里省略了
	var b = 7
	println(b)

	// 这里 uint 不能省略，否则会被解释成 int 类型
	var c uint = 8
	println(c)

	// 只声明不赋值，则默认零值。此时，类型不可以省略
	var d int
	println(d) // 0
}
```

说明：
- 驼峰式命名
- 首字符是否大写控制了访问性：大写则包外可访问
- golang 支持**类型推断**

### 短变量声明：`name := value`
```go
func main() {
	// 短变量声明
	e := 55
	println(e)
}
```

说明：
- 这种类型的说明只能用于局部变量，即方法内部。此时，golang 会进行类型推断，数字会被理解为 int 或者 float64。
- 短变量声明左边一定要有至少一个未声明变量。

### 注意事项
- 同作用域下，同名变量只能声明一次
  - 因此，允许全局变量和局部变量同名
- 易错点
  - 变量声明了未使用
  - 类型不匹配

## 常量声明 `const`

```go
const internal = "包内可访问"
const External = "包内包外都可访问"

func main() {
	const a = "hello"
	println(a)
}
```

- 首字符是否大写控制了访问性：大写包外可访问。
- 驼峰命名
- 支持类型推断
- 无法修改值

# 方法

## 方法声明：`func funcName([<name type>]) [<name type>]`

```go
// 只有一个返回值，不需要用括号括起来
func Func0(name string) string {
	return "Hello, " + name
}
// 多个参数，多个返回值，参数有名字，返回值没有
func Func1(a string, b int) (int, string) {
	return 33, "Ciao!"
}
// 返回值有名字，可以在内部直接复制，然后返回
// 也可以忽略命名的返回值，直接返回别的
func Func2(a string, b string) (age int, name string) {
	age = 18
	name = "Elena"

	return
	// 或者可以这样
	// return 18, "Elena"
}
// 多个参数具有相同类型放在一起，可以只写一次类型
func Func3(a, b, c string, abc, bcd int, p string) (d, e int, g string){
	d = 13
	e = 14
	g = "Ciao Ciao"
	return
}
// 不定参数。不定参数要放在最后面
func Func4(a string, b int, names...string){
	// 使用时，可以直接把 names 看成切片
	for _, name := range names {
		fmt.Println(name)
	}
}
```

包括四个部分：
- 关键字 `func`
- 函数名 funcName：首字母是否大写决定了作用域
- 参数列表：`[<name type>]`
- 返回列表：`[<name type>]`
  - 支持多返回值
  - 可以命名，也可以不命名

## 方法调用

```go
func main() {
	a := Func0("Elena")
	println(a)

	b, c := Func1("a", 18)
	println(b)
	println(c)

	// 使用 _ 忽略返回值
	_, d := Func2("a", "b")
	println(d)

	// 不定参数后面可以传递多个值
	Func4("Ciao", 22, "Luca", "Maria")
	s := []string{"Julia", "Caro"}
	Func4("Ciao", 25, s...)
}
```

# 参考
- [极客时间：Go 进阶训练营]()