原文：[ Language Mechanics On Stacks And Pointers](https://www.goinggo.net/2017/05/language-mechanics-on-stacks-and-pointers.html)

---

### 前言

这是一个包含四个部分的系列文，它将帮助你理解 Go 中的指针、堆栈、逃逸分析和值/指针语义背后的机制和设计。这是第一篇。本文着重于堆栈和指针。

该序列文四个部分的索引： 
1) [堆栈和指针的语言机制](https://www.goinggo.net/2017/05/language-mechanics-on-stacks-and-pointers.html)  
2) [逃逸分析的语言机制](https://www.goinggo.net/2017/05/language-mechanics-on-escape-analysis.html)  
3) [内存概要的语言机制](https://www.goinggo.net/2017/06/language-mechanics-on-memory-profiling.html)  
4) [数据和语义上的设计哲学](https://www.goinggo.net/2017/06/design-philosophy-on-data-and-semantics.html)

### 介绍

我不会粉饰指针，它是很难理解的。使用不当时，指针会产生讨厌的错误，甚至造成性能问题。这在编写并发或者多线程软件的时候尤其如此。难怪有那么多的语言试图对程序员隐藏指针。但是，如果你用 Go 编写软件，那么就不可能避免它们。如果没有深入了解指针，那么你将很难编写干净简单且有效的代码。

### 帧边界

函数在帧边界内执行，而帧边界为每个函数提供了单独的内存空间。每个帧都允许函数在自己的上下文中运行，并且还提供流控制。每个函数都能通过帧指针直接访问其帧内的内存，但是要访问帧之外的内存，则需要间接访问。为了让函数可以访问帧之外的内存，必须与函数共享该内存。必须首先了解和学习这些帧边界建立的机制和限制。

调用函数时，两个帧之间会发生过渡。代码从调用函数的帧过渡到被调用函数的帧。如果函数调用时需要数据，那么必须在两个帧之间传输。在 Go 中，两个帧之间是“按值”传递数据的。

“按值”传递数据的好处是可读性。你在函数调用中看到的值会被另一端所复制并且接收。这就是为什么我把“按值传递”与所见即所得联系在一起的原因，因为你所看到的就是所得到的。所有这些都能让你编写不隐藏两个函数之间的过渡成本的代码。这有助于保持良好的思维模式：每次函数调用都将如何在过渡发生时影响程序。

看一下下面这个小程序，它执行一个函数调用，“按值”传递整数数据：

**清单 1**
    
    
    01 package main
    02
    03 func main() {
    04
    05    // 声明一个类型为 int 的变量，初始值为 10
    06    count := 10
    07
    08    // 显示 count 的“值”和“地址”
    09    println("count:\tValue Of[", count, "]\tAddr Of[", &count, "]")
    10
    11    // 传递 count 的“值”
    12    increment(count)
    13
    14    println("count:\tValue Of[", count, "]\tAddr Of[", &count, "]")
    15 }
    16
    17 //go:noinline
    18 func increment(inc int) {
    19
    20    // 增加 inc 的“值“
    21    inc++
    22    println("inc:\tValue Of[", inc, "]\tAddr Of[", &inc, "]")
    23 }
    

当你的 Go 程序启动时，运行时将创建主 goroutine 来执行所有初始化代码，包括 `main` 函数内的代码。goroutine 是防止在最终会在某些内核上执行的操作系统线程上的执行路径。从 1.8 版本开始，每个 goroutine 都会获得一个初始为 2,048 字节的连续内存块，这个块形成了它的堆栈空间。多年以来，这个初始堆栈大小发生了变化，未来也可能会再次更改。

堆栈很重要，因为它为分配给每个单独的函数的帧边界提供了物理内存空间。在清单 1 中，当主 goroutine 执行 `main` 函数的时候，这个 goroutine 的堆栈（在非常高的层次）看起来像这样：

**图 1**

![](https://www.ardanlabs.com/images/goinggo/80_figure1.png)

在图 1 中，你可以看到已经为 `main` 函数“框”出了一部分堆栈。这一部分称为“堆栈帧”，正是这个帧表示了 `main` 函数在堆栈上的边界。这个帧是作为函数被调用时执行的代码的一部分建立的。你还可以看到 `count` 变量已经被放在 `main` 函数的帧内地址为 `0x10429fa4` 的地方。

图 1 还清楚地说明了另一个有趣的问题。活跃帧下面的所有堆栈内存都是无效的，但是活跃帧及其上方的内存都是有效的。需要弄清楚堆栈有效部分和无效部分之间的边界。

### 地址

变量的目的是为特定的内存位置分配名称，以提高代码的可读性，并且帮助你推断正在使用的数据。如果你有一个变量，那么你在内存中就有了一个值。而如果你在内存中有一个值，那么它就必须有地址。在 09 行中，`main` 函数调用了内置函数 `println` 来显示 `count` 变量的“值”和“地址”。

**清单 2**
    
    
    09    println("count:\tValue Of[", count, "]\tAddr Of[", &count, "]")
    

使用 `&` 运算符来获取变量所在位置的地址并不是什么新鲜事，其他语言也使用这个运算符。如果你在 32 位架构（例如在 playground 上）上运行这个代码，那么 09 行的输出应与下面类似：

**清单 3**
    
    
    count:  Value Of[ 10 ]  Addr Of[ 0x10429fa4 ]
    

### 函数调用

接下来在第 12 行，`main` 函数调用了 `increment` 函数。

**清单 4**
    
    
    12    increment(count)
    

函数调用意味着 goroutine 需要在堆栈上框出一部分新的内存。但是，事情有点复杂。为了成功进行这次函数调用，数据需要跨帧边界传递，并且在此期间放到新的帧上。具体来说，期望在此调用中复制并传递一个整数值。你可以查看第 18 行上的 `increment` 函数声明来了解此要求。
**清单 5**
    
    
    18 func increment(inc int) {
    

从第 12 行的 `increment` 函数的调用，你可以看到，代码正在传递 `count` 变量的值。这个值会被复制、传递和放置在 `increment` 函数的新帧中。记住，`increment` 函数只能直接读写自己帧内的内存，因此，它需要 `inc` 变量来接收、存储和访问只属于它自己的传递的 `count` 的值的副本。

在 `increment` 函数中的代码开始执行之前，goroutine 的堆栈（在非常高的层次）看起来像这样：

**图 2**

![](https://www.ardanlabs.com/images/goinggo/80_figure2.png)

可以看到，堆栈现在有两个帧，一个是 `main` 的，在其之下是 `increment` 的。在 `increment` 的帧内，你可以看到 `inc` 变量，它的值是 `10`，这个值是在函数调用期间拷贝和传递过来的。`inc` 变量的地址是 `0x10429f98`，位于内存中较低的位置，因为堆栈是向下取帧的。这只是实现细节，没有任何意义。重要的是，goroutine 在 `main` 的帧里获取 `count` 的值，然后在 `increment` 帧中使用 `inc` 变量保存该值的副本。

`increment` 内的其余代码增加并展示 `inc` 变量的值和地址。

**清单 6**
    
    
    21    inc++
    22    println("inc:\tValue Of[", inc, "]\tAddr Of[", &inc, "]")
    

playground 中第 22 行的输出应如下所示：

**清单 7**
    
    
    inc:    Value Of[ 11 ]  Addr Of[ 0x10429f98 ]
    

这是执行相同代码后堆栈的样子：

**图 3**

![](https://www.ardanlabs.com/images/goinggo/80_figure3.png)

执行第 21 和 22 行后，`increment` 函数返回，控制权重新回到 `main` 函数。然后，`main` 函数在第 14 行重新显示局部变量 `count` 的值和地址。

**清单 8**
    
    
    14    println("count:\tValue Of[",count, "]\tAddr Of[", &count, "]")
    

playground 中该程序的完整输出应如下所示：

**清单 9**
    
    
    count:  Value Of[ 10 ]  Addr Of[ 0x10429fa4 ]
    inc:    Value Of[ 11 ]  Addr Of[ 0x10429f98 ]
    count:  Value Of[ 10 ]  Addr Of[ 0x10429fa4 ]
    

`main` 的帧中的 `count` 在 `increment` 调用前后保持一致。

### 函数返回

函数返回并且控制权回到调用者时，堆栈上的内存实际上发生了什么呢？简单回答就是，什么都没有。`increment` 函数返回后，堆栈如下所示：

**图 4**

![](https://www.ardanlabs.com/images/goinggo/80_figure4.png)

堆栈看起来完全跟图 3 一样，但是 `increment` 函数相关联的帧现在被认为是无效内存。这是因为 `main` 的帧现在是活跃帧。为 `increment` 函数分配的内存保持不动。

清理返回函数的帧内存将浪费时间，因为你不知道是否还会再次需要此内存。因此，这块内存会保持不变。是在每次函数调用期间，获取帧的时候，这个帧的堆栈内存才会被清除干净。这是通过初始化放置在帧中的任何值来完成的。因为所有的值都至少会被初始化为它们的“零值”，所以每次函数调用，堆栈都会正确地进行自我清理。

### 共享值

如果要 `increment` 函数直接操作 `main` 的帧中存在的 `count` 变量，该怎么办呢？这就是指针的用武之处了。指针服务于一个目的：共享函数中的值，这样，即使该值并不直接存在于函数自己的帧中，函数也能对其进行读写。

如果你没有说出“共享”这一个词，那么就不需要使用指针。在学习指针的时候，重要的是使用一个清晰的词进行思考，而不是操作符或者语法。因此，请记住，指针是用于共享的，在你读代码的时候，请将 `&` 操作符替换成单词“共享”。

### 指针类型

对于声明的每一个类型，无论是你还是语言自身声明的，你都可以免费获得一个可用于共享的补充指针类型。已经存在一个名为 `int` 的内置类型，因此就有一个名为 `*int` 的补充指针类型。如果你声明了一个名为 `User` 的类型，那么将免费获得一个名为 `*User` 的指针类型。

所有的指针类型都有相同的两个特征。首先，它们以字符 `*` 开头。其次，它们都有相同的内存大小和表示形式，即大小为 4 或者 8 字节，表示一个地址。在 32 位架构（例如 playground），指针需要 4 字节内存，而在 64 位架构上（例如你的计算机)，它们需要 8 字节内存。

_在规范中，[指针类型](https://golang.org/ref/spec#PointerType)被认为是[类型文字](https://golang.org/ref/spec#Types)，这意味着它们是由现有类型组成的未命名类型。_

### 间接内存访问

看看这个小程序，它进行函数调用并“按值”传递一个地址。这将会和 `increment` 函数共享 `main` 的堆栈帧中的 `count` 变量：

**清单 10**
    
    
    01 package main
    02
    03 func main() {
    04
    05    // 声明一个类型为 int 的变量，初始化值为 10
    06    count := 10
    07
    08    // 显示 count 的值和地址
    09    println("count:\tValue Of[", count, "]\t\tAddr Of[", &count, "]")
    10
    11    // 传递 count 的地址
    12    increment(&count)
    13
    14    println("count:\tValue Of[", count, "]\t\tAddr Of[", &count, "]")
    15 }
    16
    17 //go:noinline
    18 func increment(inc *int) {
    19
    20    // 增加 “指针指向”的 count 的值 (dereferencing)
    21    *inc++
    22    println("inc:\tValue Of[", inc, "]\tAddr Of[", &inc, "]\tValue Points To[", *inc, "]")
    23 }
    

与原始程序相比，这个程序有三个有趣的改变。第 12 行是第一个改变：

**清单 11**
    
    
    12    increment(&count)
    

这次在第 12 行，代码不是拷贝并传递 `count` 的值，而是拷贝并传递 `count` 的地址。你现在可以说，我正在和 `increment` 函数“共享” `count` 变量。这就是 `&` 操作符所暗示的：“共享”。

要理解这仍然是“按值传递”，唯一的不同是，你传递的值是一个地址而不是一个整数。地址也是值。这是为函数调用跨帧边界拷贝和传递的值。

由于拷贝并传递了一个地址的值，因此在 `increment` 的帧中，你需要用一个变量来接收和存储这个基于整数的地址。这就是为什么在第 18 行会出现整数指针变量的声明。

**清单 12**
    
    
    18 func increment(inc *int) {
    

如果你在传递的是一个 `User` 值的地址，那么需要将该变量声明为 `*User`。即使所有的指针变量都存储地址值，但是并不是任何地址都能传递的，只能传递与指针类型相关联的地址。这是关键，共享值的原因是，接收这个值的函数需要对该值进行读写。为了进行读写，需要值的类型信息。编译器会确保只和函数共享与正确的指针类型相关联的值。

这是调用 `increment` 函数后堆栈的样子：

**图 5**

![](https://www.ardanlabs.com/images/goinggo/80_figure5.png)

在图 5 中，你可以看到，使用地址作为值进行“按值传递”时，堆栈的样子。`increment` 函数的帧内的指针变量现在指向 `count` 变量，这个变量位于 `main` 的帧中。

现在，使用指针变量，函数可以对 `main` 帧中的 `count` 变量进行间接的读取、修改和写操作。

**清单 13**
    
    
    21    *inc++
    

这次，`*` 字符充当操作符，应用于指针变量。将 `*` 用作操作符意味着，“指针指向的值”。指针变量允许对使用该变量的函数的帧之外的内存进行间接访问。有时，这种间接读取或者写入称为解引用指针。在 `increment` 函数的帧中仍然需要一个指针变量，这样它才能直接读取，以执行这种间接访问。

现在，在图 6 中，你可以看到第 21 行执行之后的堆栈。

**图 6**

![](https://www.ardanlabs.com/images/goinggo/80_figure6.png)

这是程序的最终输出：

**清单 14**
    
    
    count:  Value Of[ 10 ]   	   	Addr Of[ 0x10429fa4 ]
    inc:    Value Of[ 0x10429fa4 ]  	Addr Of[ 0x10429f98 ]   Value Points To[ 11 ]
    count:  Value Of[ 11 ]   	   	Addr Of[ 0x10429fa4 ]
    

你可以看到，`inc` 指针变量的值和 `count` 变量的地址是一样的。这就建立了共享关系，允许间接访问帧外内存。一旦 `increment` 函数通过这个变量进行了写操作，那么当控制权返回的时候，`main` 函数就会看到更改。

### 指针变量并不特别

指针变量并不特别，因为它们是变量，就像其他变量一样。会对它们进行内存分配，并且它们也持有值。只是碰巧所有的指针变量，无论它们可以指向的值的类型是什么，始终都具有相同的大小和表示形式。会让人困惑的是，`*` 字符在代码中是一个操作符，并且还用于声明指针类型。如果你可以将类型声明和指针操作区分开来，那么就可以减轻一些疑惑。

### 总结

本文描述了指针的目的以及 Go 语言中堆栈和指针机制的工作方式。这是理解编写一致且刻度的代码所需的机制、设计哲学和准则的第一步。

总而言之，下面是你学到的：

  * 函数在帧边界的范围内执行，帧边界为每个函数提供了单独的内存空间。
  * 调用一个函数时，两个帧之间会发生过渡。
  * “按值”传递数据的好处是可读性。
  * 堆栈很重要，因为它为分配给每个函数的帧边界提供了物理存储空间。
  * 活跃帧下面的所有堆栈内存是无效的，但是活跃帧及其上方的内存都有效。
  * 进行函数调用意味着，goroutine 需要在堆栈上框出一部分新内存。
  * 是在每次函数调用期间，获取帧的时候，这个帧的堆栈内存才会被清除干净。
  * 指针服务于一个目的：共享函数中的值，这样，即使该值并不直接存在于函数自己的帧中，函数也能对其进行读写。
  * 对于声明的每一个类型，无论是你还是语言自身声明的，你都可以免费获得一个可用于共享的补充指针类型。
  * 指针变量允许间接访问使用该变量的函数的帧之外的内存。
  * 指针变量并不特别，因为它们是变量，就像其他变量一样。会对它们进行内存分配，并且它们也持有值。


