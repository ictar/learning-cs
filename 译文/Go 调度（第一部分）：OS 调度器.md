原文：[scheduling-in-go-part1](https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html)

---


### 前言

这是一个包含三个部分的系列文，它将向你提供对 Go 调度器背后对机制和语义的理解。这是第一篇。本文着重于操作系统调度器。

该序列文三个部分的索引：
1) [Go 调度（第一部分）：OS 调度器](https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html)  
2) [Go 调度（第二部分）：Go 调度器](https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html)  
3) [Go 调度（第三部分）：并发](https://www.ardanlabs.com/blog/2018/12/scheduling-in-go-part3.html)

### 介绍

Go 调度器的设计和行为让你的多线程 Go 程序更加地高效以及高性能。这要归功于 Go 调度器对操作系统调度器的硬件协同（mechanical sympathy）。但是，如果你的多线程 Go 软件的设计和行为与调度器达不到硬件协同，那么这些都将不重要。对操作系统和 Go 调度器如何工作的一般性和代表性理解，对于正确设计多线程应用很重要。

这篇由多部分组成的文章将重点讨论调度器的更高级别的机制和语义。我会提供足够的细节，让你可以直观地了解其工作方式，以便做出更好的工程决策。虽然你需要为多线程应用做出大量的工程决策，但是其机制和语义仍然是你所需的基础知识的关键部分。

### OS 调度器

操作系统调度器都是复杂的软件。它们必须考虑运行它们的硬件的布局和设置。这包含但不限于多处理器和多核、[CPU 缓存和 NUMA](http://frankdenneman.nl/2016/07/06/introduction-2016-numa-deep-dive-series)。不懂这些，调度器将无法尽可能的高效。很棒的是，你仍然可以在不需要深入探讨这些主题的情况下，为操作系统调度器的工作方式建立良好的思维模型。

你的程序只是一系列的机器指令，它们需要依次执行。为此，操作系统使用线程。线程的工作是解释并顺序执行分配给它的指令集。一直执行至没有更多的指令要执行为止。这就是为什么我将线程称为“执行路径”。

你所运行的每个程序都会创建一个进程，并且会为每个进程分配一个初始线程。线程能够创建更多的线程。所有这些线程独立运行，而调度决策是在线程级别做出的，而不是进程级别。线程可以并发运行（在单个内核上轮流运行），或者并行运行（在不同内核上同时运行）。线程还会维护它们自己的状态，这样才能安全、独立且本地执行其指令。

操作系统调度器负责在有正在执行的线程的情况下，确保内核不处于空闲状态。它还必须创造一种所有可以执行的线程正在同时执行的错觉。在创造这种错觉的过程中，调度器需要确保高优先级的线程比低优先级的线程更先运行。但是，低优先级的线程也不会因没有执行时间而被饿死。调度器还需要通过做出快速且明智的决策，以最大程度减少调度延迟。

为了实现这一目标，算法需要权衡很多。但幸运但是，业内有数十年的工作和经验可以利用。为了更好地理解这些，最好描述并定义一些重要的概念。

### 执行指令

[程序计数器](https://en.wikipedia.org/wiki/Program_counter) (PC)，有时被称为指令指针（IP），它允许线程跟踪下一个要执行的指令。在大多数处理器中，PC 指向下一条指令，而不是当前指令。

**图 1**  
![](https://www.ardanlabs.com/images/goinggo/92_figure1.jpeg) <https://www.slideshare.net/JohnCutajar/assembly-language-8086-intermediate>

如果你曾经看过 Go 程序的堆栈跟踪，那么可能已经注意到每行末尾的那些小小的十六进制数字。看看清单 1 中的 `+0x39` 和 `+0x72`。

**清单 1**
    
```    
goroutine 1 [running]:
    main.example(0xc000042748, 0x2, 0x4, 0x106abae, 0x5, 0xa)
        stack_trace/example1/example1.go:13 +0x39                 <- 看这里
    main.main()
        stack_trace/example1/example1.go:8 +0x72                  <- 看这里
```    

这些数字表示从相应函数顶部的 PC 偏移值。`+0x39` PC 偏移值表示，如果程序没有 panic，线程将会执行 `example` 函数里的下一个指令。`0+x72` PC 偏移值则是在控制权回到 `main` 函数后要执行的下一个指令。更重要的是，该指针之前的指令告诉你正在执行什么指令。

看看下面清单 2 的程序，它导致了清单 1 的堆栈跟踪。

**清单 2**
    
```    
https://github.com/ardanlabs/gotraining/blob/master/topics/go/profiling/stack_trace/example1/example1.go

07 func main() {
08     example(make([]string, 2, 4), "hello", 10)
09 }

12 func example(slice []string, str string, i int) {
13    panic("Want stack trace")
14 }
```    

十六进制数 `+0x39` 表示 `example` 函数里一条指令的 PC 偏移，该偏移比函数的起始指令低 57（基数为 10）字节。在下面的清单 3 中，你可以看到来自二进制文件的 `example` 函数的一个 `objdump`。 找到底部列出的第 12 条指令。注意，这条指令上面的那行代码是对 `panic` 的调用。

**清单 3**
    
```    
$ go tool objdump -S -s "main.example" ./example1
TEXT main.example(SB) stack_trace/example1/example1.go
func example(slice []string, str string, i int) {
  0x104dfa0		65488b0c2530000000	MOVQ GS:0x30, CX
  0x104dfa9		483b6110		CMPQ 0x10(CX), SP
  0x104dfad		762c			JBE 0x104dfdb
  0x104dfaf		4883ec18		SUBQ $0x18, SP
  0x104dfb3		48896c2410		MOVQ BP, 0x10(SP)
  0x104dfb8		488d6c2410		LEAQ 0x10(SP), BP
  panic("Want stack trace")
  0x104dfbd		488d059ca20000	LEAQ runtime.types+41504(SB), AX
  0x104dfc4		48890424		MOVQ AX, 0(SP)
  0x104dfc8		488d05a1870200	LEAQ main.statictmp_0(SB), AX
  0x104dfcf		4889442408		MOVQ AX, 0x8(SP)
  0x104dfd4		e8c735fdff		CALL runtime.gopanic(SB)
  0x104dfd9		0f0b			UD2              <--- 看这里 PC(+0x39)
```    

记住，PC 是下一条要执行的指令，而不是当前执行的指令。清单 3 是基于 amd64 指令的一个很好的示例，这个 Go 程序的线程负责顺序执行。

### 线程状态

另一个重要的概念是线程状态，它规定了调度程序在线程中扮演的角色。一个线程可以处于以下三种状态之一：等待态、可运行态或者执行态。

**等待态**：这意味着线程已经被停止，并且正等待某些东西以继续执行。原因可能是诸如等待硬件（磁盘、网络）、操作系统（系统调用）或者同步调用（原子、互斥）之类。这种类型的[延迟](https://en.wikipedia.org/wiki/Latency_\(engineering\))是导致性能下降的根本原因。

**可运行态**：这意味着线程需要内核时间，以便执行分配的机器指令。如果有很多需要时间的线程，那么线程必须等待更长的时间才能获取到内核时间。此外，随着越来越多的线程争夺内核时间，任何给定线程获得的时间都将被缩短。这种类型的调度等待时间也有可能是性能下降的原因。

**执行态**：这意味着线程已经被放置在内核上并且正在执行其机器指令。与应用相关的工作已经完成。这就是每个人都想要的。

### 工作类型

线程可以执行两种类型的工作。第一种称为计算密集型，第二种称为 IO 密集型。

**计算密集型**：这类型的工作永远都不会让线程处于等待状态。这是一类不断进行计算的工作。计算 Pi 到第 N 位的线程就是计算密集型的。

**IO 密集型**：这类型的工作会导致线程进入等待态。这类工作包括请求通过网络访问的资源，或者对操作系统进行系统调用。需要访问数据库的线程将是 IO 密集型的。我将把会引发线程等待的同步事件（互斥、原子）归为此类。

### 上下文切换

如果你在 Linux、Mac 或者 Windows 上运行应用，那么就是在具有抢占式调度程序的操作系统上运行。这意味着一些重要的事情。首先，这意味着，在任何给定的时间里选择要运行的线程时，调度器都是不可预测的。线程优先级和事件（例如接收网络上的数据）使得无法确定调度器将选择做什么以及何时去做。

其次，这也意味着，你绝不能基于某些之前碰巧遇到但不能保证每次都发生的经验来编写代码。你很容易会这样想：因为我已经看到相同的事情发生 1000 次了，这肯定是有保证的行为。如果需要在程序中确定（某些行为一定会发生），则必须控制线程的同步和编排。

在内核上交换线程的无理行为称为上下文切换。当调度器从内核上撤下一个执行态线程，并替换上一个可运行的线程时，就会发生上下文切换。从运行队列上选择的线程将进入执行态。被撤下的线程可以回到可运行态（如果它仍具有运行能力的话），或者等待态（如果它是由于 IO 密集型请求而被替换的话）。

上下文切换被认为是昂贵的，因为在内核上替换上以及替换下线程都需要时间。上下文切换期间的延迟等待量取决于不同的因素，但它花费[约 1000 到 1500 纳秒](https://eli.thegreenplace.net/2018/measuring-context-switching-and-memory-overheads-for-linux-threads/)并非不合理。考虑到硬件应该能够合理地（平均）每核[每纳秒执行 12 条指令](https://www.youtube.com/watch?v=jEG4Qyo_4Bc&feature=youtu.be&t=266)，因此上下文切换可能会耗费大约 12000 到 18000 的指令延迟。本质上，程序在上下文切换期间将失去执行大量指令的能力。

如果你的程序是 IO 密集型，那么上下文切换将是一种优势。一旦一个线程进入了等待态，另一个可运行态的线程将会替代它。这使得内核始终都在工作。这是调度最重要的方面之一。如果有工作（线程处于可运行态）要完成，那么不允许内核闲置。

如果程序是计算密集型，那么上下文切换将成为性能噩梦。由于线程总是有工作要做，因此上下文切换会阻止它正在进行的工作。这种情况与 IO 密集型的工作负载形成鲜明的对比。

### 少即是多

在早期处理器只有一个内核的那个时候，调度并没有那么复杂。因为只有一个单内核的处理器，因此，在任何给定时间内只能执行一个线程。（调度的）思想是定义一个[调度器周期](https://lwn.net/Articles/404993/)，然后在该时间周期内尝试执行所有可运行线程。没问题：取得调度周期，然后将其除以需要执行的线程数。

例如，如果将调度器周期定义为 10 毫秒，并且你有两个线程，那么每个线程将获得 5 毫秒的调度时间。如果有 5 个线程，那么每个线程获得 2 毫秒的调度时间。但是，如果有 100 个线程呢？为每个线程分配 10 微秒的时间片是行不通的，因为你将在上下文切换中花费大量时间。

你需要的是限制最小时间片。在上面最后一种情况下，如果最小时间片是 2 毫秒而你有 100 个线程，那么调度周期需要增加到 2000 毫秒或者 2 秒。如果有 1000 个线程怎么办？现在，你的调度器周期为 20 秒。如果每个线程都用完它的整个时间片的话，那么在这个简单示例中，所有的线程运行一次就需要 20 秒。

请注意，这只是简单一瞥。在做[调度决策](https://blog.acolyer.org/2016/04/26/the-linux-scheduler-a-decade-of-wasted-cores/)时，调度器还需要考虑和处理更多的事情。你可以控制应用中使用的线程数。当需要考虑更多的线程，并且 IO 密集型的工作正在进行时，就会出现更多混乱且不确定的行为。此时需要更长的时间来调度和执行。

这就是为什么游戏规则是“少即是多”的原因。更少可运行态的线程意味着更少的调度时间，并且每个线程获得的时间更多。更多可运行态的线则意味着每个线程获得的时间更少。这也意味着随着时间的推移，完成的工作更少。

### 寻找平衡

在拥有的内核数量和应用要获得最佳吞吐量所需的线程数量之间，你需要找到一个平衡点。在管理这种平衡时，线程池是一个不错的方案。在第二部分，我将向你展示， Go 不再需要这样做。我认为，这是 Go 用来简化多线程应用开发的事情之一。

在用 Go 编码之前，我在 NT 上写 C++ 和 C#。在那个操作系统上，使用 IOCP（IO 完成端口）线程池对于编写多线程软件是至关重要的。作为工程师，你需要确定所需线程池的数目以及任何给定线程池的最大线程数，以最大程度提高给定内核数的吞吐量。

当编写与数据库通信的 Web 服务时，每个内核 3 个线程这个神奇的数字似乎总是可以提供 NT 上最佳吞吐量。换句话说，每个内核 3 个线程可以最小化上下文切换的延迟成本，同时最大化每个内核的执行时间。在创建 IOCP 线程池时，我知道为主机上标识的每个内核启动最少 1 个最大 3 个线程。

如果每个内核使用 2 个线程，那么完成所有工作的时间会更长，因为在本来可以用来完成工作的时间空闲了。如果每个内核使用 4 个线程，也会需要更长的时间，因为有更多的延迟在上下文切换上。无论处于何种原因，每个内核上 3 个线程的平衡似乎总是 NT 上的魔法数字。

如果你的服务正在执行许多不同类型的工作怎么办？这可能会产生不同且不一致的延迟。也许它还会创建许多需要处理的不同的系统级别的事件。不可能找到一个在不同工作负载下始终都有效的魔法数字。当使用线程池来调整服务性能时，寻找正确的一致配置会变得非常复杂。

### 高速缓存线

从主储存器访问数据具有很高的延迟成本（约 100 到 300 个时钟周期），因此，处理器和内核都有本地缓存来让数据保持靠近在需要它的硬件线程。从缓存访问数据的成本要低得多（约 3 到 40 个时钟周期），具体取决于要访问的缓存。如今，性能的一个方面是关于如何有效地将数据输入到处理器以减少这些数据的访问延迟。编写改变状态的多线程应用需要考虑缓存系统的机制。

**图 2**

![](https://www.ardanlabs.com/images/goinggo/92_figure2.png)

使用[高速缓存线](https://www.youtube.com/watch?v=WDIkqP4JbkE)在处理器和主存储器之间交换数据。一条缓存线是一个在主存储器和缓存系统之间交换的 64 字节的内存块，每个内核都会获得任何所需高速缓存线（只属于自己）的副本，这意味着硬件会使用[值语义](https://www.ardanlabs.com/blog/2017/06/design-philosophy-on-data-and-semantics.html)。这就是为什么多线程应用中的内存改变会造成性能噩梦的原因。

当并行运行当多个线程访问相同的数据，甚至是彼此接近的数据值时，它们将访问同一个高速缓存线上的数据。在任何内核上运行的任何线程将会获得同一高速缓存线只属于自己的副本。

**图 3**

![](https://www.ardanlabs.com/images/goinggo/92_figure3.png)

如果给定内核上的一个线程更改了其缓存线的副本，那么借助硬件的魔法，同一个缓存线的所有其他副本都必须被标记为脏（dirty）。当线程试图对标记为脏对缓存线进行读写访问时，需要访问主存储器（约 100 到 300 个时钟周期）才能获取该缓存线到新副本。

或许在两核处理器上这没有什么大不了，但是如果在 32 核处理器上并行运行的 32 个线程都访问和更改同一个高速缓存线上的数据呢？如果是一个具有两个 16 核的物理处理器又如何？由于增加了处理器间通信的延迟，因此情况将变得更糟糕。该应用将遍历内存，因此性能将非常糟糕，并且你很有可能会不明白为什么。

这称为[高速缓存一致性问题](https://youtu.be/WDIkqP4JbkE)，并且也引入了像错误共享这一类的问题。当编写会改变共享状态的多线程应用程序时，必须考虑缓存系统。

### 调度决策场景

想象一下，我已经要求你根据提供的高级信息编写 OS 调度器了。考虑一种你必须考虑的情况。记住，这是调度器在做出调度决策时必须考虑的许多有趣的事情之一。

启动应用，创建主线程，主线程运行在内核 1 上。随着线程开始执行指令，由于需要数据，因此检索高速缓存线。现在，线程决定为某些并发处理创建一个线程。下面是问题。

创建线程并准备就绪后，调度器应该：

  1. 上下文切换下内核 1 上的主线程？这样做能提高性能，因为有可能这个新线程所需要的相同的数据已经很好的缓存起来了。但是，主线程无法获得其全部的时间片。
  2. 线程是否应该等待主线程的时间片完成后内核 1 可用？线程未运行，但一旦它启动，将消除获取数据的延迟。
  3. 线程是否应该等待下一个可用的内核？这意味着将清除、检索和复制所选内核的高速缓存线，从而导致延迟。但是，线程将更快地启动，并且主线程可以完成其时间片。



觉得有意思了没？这些就是 OS 调度器进行调度决策时需要考虑的有趣的问题。幸运的是，我并非做出决策的那个人。我只能告诉你，如果有一个空闲的内核，它将被使用。你希望在线程可以运行时运行它。

### 总结

文章的第一部分提供了在编写多线程应用时，你必须考虑的有关线程和 OS 调度器的一些见解。这些也是 Go 调度器要考虑的事情。在下一篇文章中，我将描述 Go 调度器的语义，以及它们是如何与这些信息相关联的。最后，通过运行几个程序，你将在实战中看到所有这些东西。