原文：[The Zen of Go](https://the-zen-of-go.netlify.com/)

---

编写煎蛋、可读可维护的 Go 代码的十条工程建议，展示于 [2020 年以色列 GopherCon](http://gophercon.org.il)。

### 一个包实现一个功能
    
设计良好的 Go 包提供了单一的功能，以及一系列相关的行为。一个好的 Go 包首先会选择一个好的命名。把你的包名想象成“电梯游说”，只用一个词来描绘它提供的功能。

### 显式处理错误

健壮的程序是由那些在沾沾自喜前就处理了失败场景的片段组成的。在每种失败场景发生的时候仔细处理它们的价值超过了冗长的 `if err != nil { return err }`。panic 和 recover 并不是异常，它们并非被设计用于这种方式。

### 尽早返回，而不是深度嵌套

每当你缩进，你都会在程序员的堆栈中添加另一个先决条件，这会消耗掉他们短期记忆里 7 ±2 个槽中的一个。避免那些要求深度缩进的控制流。与其深度嵌套，还不如使用保护子句来将成功的路径保持在左侧。

### 将并发留给调用者

让调用者自个选择是否要异步运行你的库或者函数，而不是强迫它们异步运行。如果你的库使用并发，那么应该透明使用。

### 在启动一个 goroutine 之前，要知道它何时会停止
    
goroutine 拥有自己的资源：锁、变量、内存等。释放这些资源的可靠方法是停止拥有这些资源的 goroutine。

### 避免包级别的状态

通过提供类型需要的依赖项作为该类型中的字段，而不是使用包变量，以追求明确性，减少耦合以及诡异的动作。

### 简单性很重要

简单性并非不复杂的代名词。简单不意味着粗糙，而是意味着 _可读_ 和 _可维护_。如果可以选择，请遵循较简单的解决方案。

### 编写测试，以锁定包 API 的行为
    
先测试还是后测试，你追求的是百分百的测试覆盖率还是觉得少测试点也没关系，不顾你得包 API 是你与它的用户之间的约定。测试是那些约定内容的保证。请确保测试那些用户可以观察以及依赖的行为。

### 如果你觉得它运行缓慢，请先通过基准测试进行验证
    
太多操作以性能为名违反了可维护性。优化会破坏抽象，暴露内部信息，以及使得耦合紧密。如果你选择承担这些风险，那么请确保有充分的理由这样做。

### 节制是一种美德

适度使用 goroutine、channel、锁、接口、嵌入。

### 可维护性很重要

清晰性、可读性和简单性是可维护性的所有方面。在你走后，你所做的那些东西会难以维护吗？当下你该如何做才能让那些以后接手的人更轻松？

