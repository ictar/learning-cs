
建议：
- 使用 benchmark
- slice
  - 尽可能在使用使用 `make()` 初始化切片时提供容量信息，预分配内存
  - 陷阱
    - 大内存未释放。
      - 例如，当原切片较大时，代码在原切片基础上新建小切片。因此，原切片的底层数组在内存中有引用，得不到释放
      - 原因：在已有切片的基础上创建切片，不会创建新的底层数组。
      - 解决方法：使用 `copy` 来替代 re-slice
- map
  - 预先分配内存：不断向 map 中添加元素的操作会触发 map 扩容。而提前分配好空间可以减少内存拷贝和 rehash 的消耗，因此，建议根据实际需求提前预估好需要的空间。
- 字符串处理
  - 字符串拼接
    - 使用 `+` 拼接性能最差。性能上 `strings.Builder` 和 `bytes.Buffer` 相近，`strings.Builder` 最快。
    - 原因：
      - 字符串在 Go 语言中是不可变类型，占用内存大小是固定的。因此，使用 `+` 每次都会重新分配内存。而  `strings.Builder` 和 `bytes.Buffer` 底层都是 []byte 数组，根据内存扩容策略扩容，而不需要每次拼接都重新分配内存。
      - `bytes.Buffer` 转化为字符串时重新申请了一块空间（使用 `string([]byte)`），而 `strings.Builder` 直接将底层的 []byte 转换成了字符串类型返回（使用 `*(*string)(unsafe.Pointer(*[]byte))`）。
- 空结构体 `struct{}`
  - 说明：空结构体实例（`struct{}{}`）不占据任何的内存空间
  - 使用：
    - 作为各种场景下的占位符
      - 节省资源
      - 空结构体本身具备很强的语义，即这里不需要任何值，仅作为占位符
    - 在使用 map 实现 set 的时候，作为 map 的值来使用。
- `atomic` 包
  - 保护变量修改：
    - 原因：
      - 锁的实现是通过操作系统来实现，属于系统调用；`atomic` 操作是通过硬件实现，效率比锁高。
      - `sync.Mutex` 应该用来保护一段逻辑，而不仅仅用来保护一个变量
      - 对于非数值操作，可以使用 `atomic.Value`，能承载一个 `interface{}`