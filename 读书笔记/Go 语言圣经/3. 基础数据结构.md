目录
=================

   * [基础数据类型](#基础数据类型)
      * [整型](#整型)
         * [int 和 uint](#int-和-uint)
         * [Unicode字符 rune 类型](#unicode字符-rune-类型)
         * [byte](#byte)
         * [无符号的整数类型 uintptr](#无符号的整数类型-uintptr)
         * [运算符](#运算符)
            * [算术运算符](#算术运算符)
            * [bit位操作运算符](#bit位操作运算符)
         * [进制](#进制)
      * [浮点数](#浮点数)
         * [打印](#打印)
         * [math 包](#math-包)
            * [浮点数的范围极限值](#浮点数的范围极限值)
            * [正无穷大、负无穷大和 NaN 非数](#正无穷大负无穷大和-nan-非数)
      * [复数](#复数)
         * [运算](#运算)
            * [math/cmplx 包](#mathcmplx-包)
      * [布尔型](#布尔型)
      * [字符串](#字符串)
         * [字符串的不变性](#字符串的不变性)
         * [字符串面值](#字符串面值)
            * [原生字符串面值](#原生字符串面值)
         * [Unicode](#unicode)
         * [UTF-8](#utf-8)
            * [应用 []rune 类型转换](#应用-rune-类型转换)
         * [unicode 包](#unicode-包)
         * [字符串和Byte切片](#字符串和byte切片)
            * [字符串和字节 slice 之间的转换](#字符串和字节-slice-之间的转换)
         * [字符串和数字的转换](#字符串和数字的转换)
            * [数字 -&gt; 字符串](#数字---字符串)
            * [字符串 -&gt; 数字](#字符串---数字)
      * [常量](#常量)
         * [iota 常量生成器](#iota-常量生成器)
         * [无类型常量](#无类型常量)


# 基础数据类型

## 整型
Go语言同时提供了有符号和无符号类型的整数运算：
* 四种有符号整数类型：int8、int16、int32和int64，分别对应8、16、32、64bit大小的有符号整数
* 四种无符号整数类型：uint8、uint16、uint32和uint64

其中有符号整数采用2的补码形式表示，也就是最高bit位用来表示符号位，一个n-bit的有符号数的值域是从$-2^{n-1}$到$2^{n-1}-1$。无符号整数的所有bit位都用于表示非负数，值域是0到$2^n-1$。

尽管Go语言提供了无符号数和运算，即使数值本身不可能出现负数我们还是倾向于使用有符号的int类型。无符号数往往只有在位运算或其它特殊的运算场景才会使用，就像bit集合、分析二进制文件格式或者是哈希和加密操作等。它们通常并不用于仅仅是表达非负数量的场合。

### `int` 和 `uint`
有符号和无符号整数 `int` 和 `uint` 对应特定CPU平台机器字大小。

这两种类型都有同样的大小，32或64bit，但是我们**不能对此做任何的假设**；因为不同的编译器即使在相同的硬件平台上可能产生不同的大小。

> 注意，int和int32是不同的类型，即使int的大小也是32bit，在需要将int当作int32类型的地方**需要一个显式的类型转换操作**，反之亦然。

### Unicode字符 `rune` 类型
和int32等价的类型，通常用于表示一个Unicode码点。这两个名称可以互换使用。

### `byte`
uint8类型的等价类型，byte类型一般用于强调数值是一个原始的数据而不是一个小的整数。

### 无符号的整数类型 `uintptr`
没有指定具体的bit大小但是足以容纳指针。

uintptr类型只有在底层编程时才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方。

### 运算符
| 优先级（0 最低） | 运算符 |
| ------ | ------ |
| 4 | `*      /      %      <<（左移）       >>（右移）     &（位运算符 AND）       &^（位清空 AND NOT）` |
| 3 | `+      -      |（位运算符 OR）      ^（位运算符 XOR）` |
|   2   | 比较运算符：`==     !=     <      <=       >      >=` |
|   1    | `&&` |
|   0    | `||` |

在同一个优先级，使用左优先结合规则，但是使用括号可以明确优先顺序，使用括号也可以用于提升优先级

一般来说，需要一个显式的转换将一个值从一种类型转化位另一种类型，并且算术和逻辑运算的二元操作中必须是相同的类型。虽然这偶尔会导致需要很长的表达式，但是它消除了所有和类型相关的问题，而且也使得程序容易理解。

#### 算术运算符
* 算术运算符 `+`、`-`、`*` 和 `/` 可以适用于整数、浮点数和复数
  * 除法运算符 `/` 的行为依赖于操作数是否为全为整数
* 取模运算符 `%` 仅用于整数间的运算。
  * 在Go语言中，%取模运算符的符号和被取模数的符号总是一致的，因此 `-5%3`和 `-5%-3` 结果都是-2。

#### bit位操作运算符
* 位操作运算符 `^` 
  * 作为二元运算符时是按位异或（XOR）
  * 用作一元运算符时表示按位取反；也就是说，它返回一个每个bit位都取反的数。
* 位操作运算符 `&^` 用于按位置零（AND NOT）
  * 如果对应y中bit位为1的话, 表达式z = x &^ y结果z的对应的bit位为0，否则z对应的bit位等于x相应的bit位的值。
* 在 `x<<n` 和 `x>>n` 移位运算中，决定了移位操作bit数部分 `n` 必须是无符号数；被操作的x数可以是有符号或无符号数。
  * 算术上，一个 `x<<n` 左移运算等价于乘以$2^n$，一个 `x>>n` 右移运算等价于除以$2^n$。

### 进制
任何大小的整数字面值都可以
* 用以0开始的八进制格式书写，例如0666；
  * 如今八进制数据通常用于POSIX操作系统上的文件访问权限标志
* 或用以0x或0X开头的十六进制格式书写，例如0xdeadbeef。
  * 十六进制数字可以用大写或小写字母。
  * 十六进制数字则更强调数字值的bit位模式。

## 浮点数
Go语言提供了两种精度的浮点数，float32和float64。它们的算术规范由IEEE754浮点数国际标准定义，该浮点数规范被所有现代的CPU支持。

一个float32类型的浮点数可以提供大约6个十进制数的精度，而float64则可以提供约15个十进制数的精度；通常应该优先使用float64类型，因为float32类型的累计计算误差很容易扩散，并且float32能精确表示的正整数并不是很大

> 注：如果不知道浮点数类型的内存大小是很难写出正确的数值算法的，因此Go语言不存在整型类似的不确定内存大小的浮点数和复数类型。

### 打印
用 `Printf` 函数的 `%g` 参数打印浮点数，将采用更紧凑的表示形式打印，并提供足够的精度，但是对应表格的数据，使用 `%e`（带指数）或 `%f` 的形式打印可能更合适。所有的这三个打印形式都可以指定打印的宽度和控制打印精度。

```golang
for x := 0; x < 8; x++ {
    // 打印 e 的幂，打印精度是小数点后 3 个小数精度和 8 个字符宽度
    fmt.Printf("x = %d  e^x = %8.3f\n", x, math.Exp(float64(x)))
}
```

### `math` 包

#### 浮点数的范围极限值
* 常量`math.MaxFloat32` 表示float32能表示的最大数值，大约是 3.4e38；
* `math.MaxFloat64` 常量大约是1.8e308。
* `math.SmallestNonzeroFloat32` 和 `math.SmallestNonzeroFloat64` 分别能表示的最小值近似为1.4e-45和4.9e-324。

#### 正无穷大、负无穷大和 NaN 非数
正无穷大和负无穷大，分别用于表示太大溢出的数字和除零的结果；还有NaN非数，一般用于表示无效的除法操作结果0/0或Sqrt(-1).

```golang
var z float64
fmt.Println(z, -z, 1/z, -1/z, z/z) // "0 -0 +Inf -Inf NaN"
```

函数 `math.IsNaN` 用于测试一个数是否是非数 `NaN`，`math.NaN()` 则返回非数对应的值。虽然可以用math.NaN来表示一个非法的结果，但是测试一个结果是否是非数NaN则是充满风险的，因为NaN和任何数都是不相等的：
```golang
nan := math.NaN()
fmt.Println(nan == nan, nan < nan, nan > nan) // "false false false"
```

## 复数
Go语言提供了两种精度的复数类型：complex64和complex128，分别对应float32和float64两种浮点数精度。
* 内置的 `complex` 函数用于构建复数
* 内建的 `real` 和 `imag` 函数分别返回复数的实部和虚部：

```golang
var x complex128 = complex(1, 2) // 1+2i
// 可以简化为 x := 1 + 2i
var y complex128 = complex(3, 4) // 3+4i
// 可以简化为 y := 3 + 4i

fmt.Println(x*y) // "(-5+10i)"
fmt.Println(real(x*y)) // "-5"
fmt.Println(imag(x*y)) // "10"
```

### 运算
在常量算术规则下，一个复数常量可以加到另一个普通数值常量（整数或浮点数、实部或虚部）。

复数也可以用==和!=进行相等比较。只有两个复数的实部和虚部都相等的时候它们才是相等的。
> 译注：浮点数的相等比较是危险的，需要特别小心处理精度问题。

#### `math/cmplx` 包
该包提供了复数处理的许多函数。

## 布尔型
一个布尔类型的值只有两种：`true` 和 `false`。

布尔值可以和&&（AND）和||（OR）操作符结合，并且**有短路行为**：如果运算符左边值已经可以确定整个布尔表达式的值，那么运算符右边的值将不再被求值。

布尔值并不会隐式转换为数字值0或1，反之亦然。

```golang
// btoi returns 1 if b is true and 0 if false
func btoi(b bool) int {
    if b {
        return 1
    }
    return 0
}

// itob reports whether i is non-zero
func itob(i int) bool { return i != 0 }
```


## 字符串
**一个字符串是一个不可改变的字节序列。**

内置的 `len` 函数可以返回一个字符串中的字节数目（不是rune字符数目），索引操作s[i]返回第i个字节的字节值，i必须满足0 ≤ i< len(s)条件约束。

```golang
s := "hello, world"
fmt.Println(len(s))     // "12"
fmt.Println(s[0], s[7]) // "104 119" ('h' and 'w')
c := s[len(s)] // panic: index out of range
// 子字符串操作s[i:j]基于原始的s字符串的第i个字节开始到第j个字节（并不包含j本身）生成一个新字符串。
// 生成的新字符串将包含j-i个字节。
fmt.Println(s[0:5]) // "hello"
// 不管i还是j都可能被忽略，
// 当它们被忽略时将采用0作为开始位置，采用len(s)作为结束的位置。
fmt.Println(s[:5]) // "hello"
fmt.Println(s[7:]) // "world"
fmt.Println(s[:])  // "hello, world"
// + 操作符将两个字符串链接构造一个新字符串
fmt.Println("goodbye" + s[5:]) // "goodbye, world"

// 字符串可以用==和<进行比较；
// 比较通过逐个字节比较完成的，因此比较的结果是字符串自然编码的顺序。
fmt.Println("ab" > "abc", "ab" > "ac", "ba" > "abc") // false false true
```

### 字符串的不变性
```golang
// 可以像下面这样将一个字符串追加到另一个字符串，
// 但是这并不会导致原始的字符串值被改变，
// 变量s将因为+=语句持有一个新的字符串值，但是t依然是包含原先的字符串值。
s := "left foot"
t := s
s += ", right foot"
fmt.Println(s) // "left foot, right foot"
fmt.Println(t) // "left foot"

// 尝试修改字符串内部数据的操作是被禁止的
s[0] = 'L' // compile error: cannot assign to s[0]
```

不变性意味如果两个字符串共享相同的底层数据的话也是安全的，这使得复制任何长度的字符串代价是低廉的。同样，一个字符串s和对应的子字符串切片s[7:]的操作也可以安全地共享相同的内存，因此字符串切片操作代价也是低廉的。在这两种情况下都没有必要分配新的内存。

![一个字符串和两个子串共享相同的底层数据](https://books.studygolang.com/gopl-zh/images/ch3-04.png)

### 字符串面值
字符串值也可以用字符串面值方式编写，只要将一系列字节序列包含在双引号即可。

在一个双引号包含的字符串面值中，可以用以反斜杠 `\` 开头的转义序列插入任意的数据。

#### 原生字符串面值
一个原生的字符串面值形式是 \`...\`，使用反引号代替双引号。在这种面值中，没有转义操作，全部的内容都是字面的意思，包含退格和换行，因此一个程序中的原生字符串面值可能跨越多行。

```golang
const GoUsage = `Go is a tool for managing Go source code.

Usage:
`
// 在原生字符串面值内部是无法直接写`字符的，可以用八进制或十六进制转义或+"`"链接字符串常量完成
```

### Unicode
[Unicode](http://unicode.org)：收集了这个世界上所有的符号系统，包括重音符号和其它变音符号，制表符和回车符，还有很多神秘的符号，每个符号都分配一个唯一的Unicode码点，Unicode码点对应Go语言中的rune整数类型。

可以将一个符文序列表示为一个int32序列。这种编码方式叫UTF-32或UCS-4，每个Unicode码点都使用同样的大小32bit来表示。这种方式比较简单统一，但是它会浪费很多存储空间。

Go语言字符串面值中的Unicode转义字符让我们可以通过Unicode码点输入特殊的字符（其中h是一个十六进制数字）：
* `\uhhhh`：16bit的码点值
* `\Uhhhhhhhh`：32bit的码点值

### UTF-8
UTF8是一个将Unicode码点编码为字节序列的变长编码。UTF8编码使用1到4个字节来表示每个Unicode码点。

* `0xxxxxxx`：runes 0-127    (ASCII)
* `110xxxxx 10xxxxxx`：128-2047       (values <128 unused)
* `1110xxxx 10xxxxxx 10xxxxxx`：2048-65535     (values <2048 unused)
* `11110xxx 10xxxxxx 10xxxxxx 10xxxxxx`：65536-0x10ffff (other values unused)

Go语言的源文件采用UTF8编码，并且Go语言处理UTF8编码的文本也很出色。**Go语言的range循环在处理字符串的时候，会自动隐式解码UTF8字符串**。

> 注意：对于非ASCII，索引更新的步长将超过1个字节。

![](https://books.studygolang.com/gopl-zh/images/ch3-05.png)

#### 应用 []rune 类型转换

```golang
s := "プログラム"
fmt.Printf("% x\n", s) // "e3 83 97 e3 83 ad e3 82 b0 e3 83 a9 e3 83 a0"
// "% x" 参数用于在每个十六进制数字前插入一个空格
/
/ 将[]rune类型转换应用到UTF8编码的字符串，将返回字符串编码的Unicode码点序列
r := []rune(s)
fmt.Printf("%x\n", r)  // "[30d7 30ed 30b0 30e9 30e0]"

// 如果是将一个[]rune类型的Unicode字符slice或数组转为string，
// 则对它们进行UTF8编码
fmt.Println(string(r)) // "プログラム"
```

### `unicode` 包
`unicode` 包提供了诸多处理rune字符相关功能的函数（比如区分字母和数组，或者是字母的大写和小写转换等），`unicode/utf8` 包则提供了用于rune字符序列的UTF8编码和解码的功能。

### 字符串和Byte切片
标准库中有四个包对字符串处理尤为重要：
* `strings` 包：提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能。
  * 函数 `ToUpper` 和 `ToLower`，将原始字符串的每个字符都做相应的转换，然后返回新的字符串。
* `bytes` 包：提供了很多类似 `strings` 包功能的函数，但是针对的是和字符串有着相同结构的[]byte类型。
  * 因为字符串是只读的，因此逐步构建字符串会导致很多分配和复制。在这种情况下，使用 `bytes.Buffer` 类型将会更有效
    * 一个 `bytes.Buffer` 变量并不需要初始化，因为零值也是有效的
    * 当向 `bytes.Buffer` 添加任意字符的UTF8编码时，最好使用 `bytes.Buffer` 的 `WriteRune` 方法，但是 `WriteByte` 方法对于写入类似'['和']'等ASCII字符则会更加有效。
* `strconv` 包：提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换。
* `unicode` 包
  * 提供了 `IsDigit`、`IsLetter`、`IsUpper` 和 `IsLower` 等类似功能，它们用于给字符分类。每个函数有一个单一的rune类型的参数，然后返回一个布尔值。
  * 像 `ToUpper` 和 `ToLower` 之类的转换函数将用于rune字符的大小写转换。
  * 所有的这些函数都是遵循Unicode标准定义的字母、数字等分类规范
  
#### 字符串和字节 slice 之间的转换
```golang
s := "abc"
// 分配了一个新的字节数组用于保存字符串数据的拷贝，
// 然后引用这个底层的字节数组。
// 即需要确保在变量b被修改的情况下，原始的s字符串也不会改变。
b := []byte(s)
// 构造一个字符串拷贝，以确保s2字符串是只读的。
s2 := string(b)
```

### 字符串和数字的转换
有时候也会使用fmt.Scanf来解析输入的字符串和数字，特别是当字符串和数字混合在一行的时候，它可以灵活处理不完整或不规则的输入。

#### 数字 -> 字符串
```golang
x := 123
// 将整数转换成字符串
// 方法一
y1 := fmt.Sprintf("%d", x) // "123"
// 方法二
y2 := strconv.Itoa(x) // "123"

// 用不同的进制来格式化数字
fmt.Println(strconv.FormatInt(int64(x), 2)) // "1111011"
// 此外，还有一个函数是 FormatUint，用于格式化无符号数字
```

#### 字符串 -> 数字
```golang
x, err := strconv.Atoi("123") // x 类型为 int
y, err := strconv.ParseInt("123", 10, 64) // 十进制，64位。y 类型为 int64
// 还有用于解析无符号整数的ParseUint函数
```

## 常量
常量表达式的值**在编译期计算**，而不是在运行期。每种常量的潜在类型都是基础类型：boolean、string 或数字。

```golang
const 常量名 常量类型 = 常量值
// 常量值不可变
// 常量类型可以省略，省略时类型根据常量值推断
// 允许批量声明多个常量，
```

常量间的所有算术运算、逻辑运算和比较运算的结果也是常量，对常量的类型转换操作或以下函数调用都是返回常量结果：len、cap、real、imag、complex和unsafe.Sizeof

因为它们的值是在编译期就确定的，因此**常量可以是构成类型的一部分**，例如用于指定数组类型的长度：
```golang
const DirLen = 4
var d [DirLen]byte
```

如果是批量声明的常量，除了第一个外其它的常量右边的初始化表达式都可以省略，如果省略初始化表达式则表示使用前面常量的初始化表达式写法，对应的常量类型也一样的。
```golang
const (
    a = 1
    b
    c = 2
    d
)
fmt.Println(a b c d) // "1 1 2 2"
```

### iota 常量生成器
`iota` 常量生成器用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。在一个const声明语句中，**在第一个声明的常量所在的行，`iota` 将会被置为0**，然后在每一个有常量声明的行加一。
```golang
type Weekday int // 在其它编程语言中，这种类型一般被称为枚举类型

const (
    Sunday Weekday = iota // 0
    Monday // 1
    Tuesday // 2
    Wednesday // 3
    Thursday // 4
    Friday // 5
    Saturday // 6
)
```

也可以在复杂的常量表达式中使用iota
```golang
type Direction uint

const (
	Up Direction = 1 << iota // 等价于 1 << 0
	Down // 等价于 1 << 1
	Left // 等价于 1 << 2
	Right // 等价于 1 << 3
	Middle // 等价于 1 << 4
)

fmt.Printf("%b\t%b\t%b\t%b\t%b\n", Up, Down, Left, Right, Middle)
// 1       10      100     1000    10000
```

### 无类型常量
虽然一个常量可以有任意有一个确定的基础类型，但是许多常量并没有一个明确的基础类型。编译器为这些没有明确的基础类型的数字常量提供比基础类型更高精度的算术运算（可以认为至少有256bit的运算精度）。

有六种未明确类型的常量类型，分别是：
* 无类型的布尔型
* 无类型的整数
* 无类型的字符
* 无类型的浮点数
* 无类型的复数
* 无类型的字符串

通过延迟明确常量的具体类型，无类型的常量不仅可以提供**更高的运算精度**，而且可以**直接用于更多的表达式而不需要显式的类型转换**。
```golang
// math.Pi无类型的浮点数常量，可以直接用于任意需要浮点数或复数的地方
var x float64 = math.Pi
var y complex128 = math.Pi
```

只有常量可以是无类型的。当一个无类型的常量被赋值给一个变量的时候，或者出现在有明确类型的变量声明的右边，无类型的常量将会被隐式转换为对应的类型，如果转换合法的话。

对于一个没有显式类型的变量声明（包括简短变量声明），常量的形式将隐式决定变量的默认类型：
```golang
i := 0 // untyped integer; implicit: int(0)
r := '\000' // untyped rune; implicit rune('\000')
f := 0.0 // untyped floating-point; implicit float64(0.0)
c := 0i // untyped complex; implicit complex128(0i)
```

当尝试将这些无类型的常量转为一个接口值时，这些默认类型将显得尤为重要，因为要靠它们明确接口对应的动态类型。