目录
=================

   * [程序结构](#程序结构)
      * [命名](#命名)
         * [关键字](#关键字)
         * [内部预定义名字](#内部预定义名字)
         * [作用域](#作用域)
      * [声明](#声明)
      * [变量](#变量)
         * [零值](#零值)
         * [初始化表达式](#初始化表达式)
         * [简短变量声明](#简短变量声明)
         * [指针](#指针)
            * [指针的零值](#指针的零值)
            * [指针作为函数返回值](#指针作为函数返回值)
            * [指针作为函数参数](#指针作为函数参数)
            * [package flag](#package-flag)
         * [new 函数](#new-函数)
         * [变量的生命周期](#变量的生命周期)
      * [赋值](#赋值)
         * [元组赋值](#元组赋值)
         * [可赋值性](#可赋值性)
      * [类型](#类型)
      * [包和文件](#包和文件)
         * [导入包](#导入包)
            * [golang.org/x/tools/cmd/goimports](#golangorgxtoolscmdgoimports)
         * [包的初始化](#包的初始化)
            * [init()](#init)
            * [扩展阅读](#扩展阅读)
      * [作用域](#作用域-1)
         * [作用域 v.s 生命周期](#作用域-vs-生命周期)
         * [当编译器遇到一个名字引用时……](#当编译器遇到一个名字引用时)
         * [隐式词法域](#隐式词法域)
         * [短变量声明语句的作用域范围](#短变量声明语句的作用域范围)


# 程序结构
## 命名
Go语言中的函数名、变量名、常量名、类型名、语句标号和包名等所有的命名，都遵循：以一个字母（Unicode 字母）或下划线开头，后面可以跟任意数量的字母、数字或下划线。区分大写字母和小写字母。

名字的长度没有逻辑限制，但是Go语言的风格是尽量使用短小的名字，对于局部变量尤其是这样。

在习惯上，Go语言程序员推荐使用**驼峰式**命名，当名字有几个单词组成的时优先使用大小写分隔，而不是优先用下划线分隔。而像ASCII和HTML这样的缩略词则避免使用大小写混合的写法。

### 关键字
共有 25 个，不能用于自定义名字，只能在特定语法结构中使用：
```
break      default       func     interface   select
case       defer         go       map         struct
chan       else          goto     package     switch
const      fallthrough   if       range       type
continue   for           import   return      var
```

### 内部预定义名字
有 30 多个，主要对应内建常量、类型和函数。不是关键字，可以在定义中重新使用它们。
1. 内建常量：`true false iota nil`
2. 内建类型：
```
int int8 int16 int32 int64
uint uint8 uint16 uint32 uint64 uintptr
float32 float64 complex128 complex64
bool byte rune string error
``` 
3. 内建函数：
```
make len cap new append copy close delete
complex real imag
panic recover
```
### 作用域
如果一个名字是在函数内部定义，那么它的就只在函数内部有效。如果是在函数外部定义，那么将在当前包的所有文件中都可以访问。

名字的开头字母的大小写决定了名字在包外的可见性。如果一个名字是大写字母开头的（译注：必须是在函数外部定义的包级名字；包级函数名本身也是包级名字），那么它将是导出的，也就是说可以被外部的包访问，例如fmt包的Printf函数就是导出的，可以在fmt包外部访问。包本身的名字一般总是用小写字母。

## 声明
声明语句定义了程序的各种实体对象以及部分或全部的属性。Go语言主要有四种类型的声明语句：
* `var`：变量声明
* `const`：常量声明
* `type`：类型声明
* `func`：函数实体声明

一个Go语言编写的程序对应一个或多个以.go为文件后缀名的源文件中。每个源文件以包的声明语句（`package xxx`）开始，说明该源文件是属于哪个包。包声明语句之后是 import 语句导入依赖的其它包，然后是包一级的类型、变量、常量、函数的声明语句，包一级的各种类型的声明语句的顺序无关紧要（译注：函数内部的名字则必须先声明之后才能使用）。

## 变量
var声明语句可以创建一个特定类型的变量，然后给变量附加一个名字，并且设置变量的初始值。变量声明的一般语法如下：

```
var 变量名字 类型 = 初始化表达式
```

其中，“类型”和“= 初始化表达式” 可以省略其中一个。
* 省略“类型”，则根据初始化表达式来推到变量的类型信息
* 省略“= 初始化表达式”，则用零值来初始化该变量

也可以在一个声明语句中同时声明一组变量：
```golang
var i, j, k int
```

或用一组初始化表达式声明并初始化一组变量：
```golang
var i, j, k int = 1, 2, 3 // int, int, int
```

如果省略每个变量的类型，将可以声明多个类型不同的变量（类型由初始化表达式推导）：
```golang
var b, f, s = true, 2.3, "string" // bool, float64, string
```

### 零值
* 数值类型：0
* 布尔类型：false
* 字符串类型：空字符串
* 接口或引用类型（包括 slice、指针、map、chan 和函数）：nil
* 数组或结构等聚合类型：每个元素或字段都是对应该类型的零值

零值初始化机制可以确保每个声明的变量总是有一个良好定义的值，因此在 Go 语言中不存在未初始化的变量。这个特性可以简化很多代码，而且可以在没有增加额外工作的前提下确保边界条件下的合理行为。

### 初始化表达式
可以是字面量或者任意表达式。在包级别声明的变量会在main入口函数执行前完成初始化，局部变量将在声明语句被执行到的时候完成初始化。

### 简短变量声明
语法：
```
变量名字 := 初始化表达式
```

* 变量类型根据表达式来自动推导
* **仅可用于局部变量的声明和初始化**

> 注意1：与赋值语句区分
> 
> 注意2：不要混淆多个变量的声明和元祖的多重赋值

简短变量声明语句中必须至少要声明一个新的变量，如果存在已经**在相同的词法域**中声明过的变量，那么对于这些已经声明过的变量只有赋值行为。例如：
```golang
in, err := os.Open(infile) 
// 声明了 in 和 err 两个变量
//...
out, err := os.Create(outfile)
// 只声明了 out 一个变量，然后对已声明对 err 进行了赋值操作
```

> 注：简短变量声明语句只有对已经在同级词法域声明过的变量才和赋值操作语句等价，如果变量是在外部词法域声明的，那么简短变量声明语句将会在当前词法域重新声明一个新的变量。

### 指针
一个变量对应一个保存了变量对应类型值的内存空间。一个指针的值是另一个变量的地址。一个指针对应变量在内存中的存储位置。并不是每一个值都会有一个内存地址，但是对于每一个变量必然有对应的内存地址。通过指针，我们可以直接读或更新对应变量的值，而不需要知道该变量的名字（如果变量有名字的话）。

```golang
x := 1 // 一个类型为 int 的变量
p := &x // 指针，类型为 *int，指向变量 x，或者说指针 p 保存了变量 x 的内存地址
fmt.Println(*p) // 表达式 *p 读取指针 p 指向的变量 x 的值。此外，*p 对应一个变量
*p = 2 // 等价于 x = 2
```

**每次我们对一个变量取地址，或者复制指针，我们都是为原变量创建了新的别名。**指针特别有价值的地方在于我们可以不用名字而访问一个变量，但是这是一把双刃剑。不仅仅是指针会创建别名，很多其他引用类型也会创建别名，例如slice、map和chan，甚至结构体、数组和接口都会创建所引用变量的别名。

#### 指针的零值
任何类型的指针的零值都是 nil。当 p 指向某个有效变量时，`p != nil` 为真。指针之间可以进行相等测试，只有当它们指向同一个变量或全部是 nil 时才相等。

```golang
var x, y int
fmt.Println(&x == &x, &x == &y, &x == nil) // true false false
var p1, p2 *int
fmt.Println(p1 == p2, p1 == nil) // true true
```

#### 指针作为函数返回值

在 Go 语言中，返回函数中局部变量的地址也是安全的。
```golang
var p = f() // 函数 f 被调用返回后，p 保存返回结果

func f() *int {
    v := 1 // 局部变量
    return &v
}

fmt.Println(f() == f()) // false
```

#### 指针作为函数参数
如果将指针作为参数调用函数，那将可以在函数中通过该指针来更新变量的值。

#### `package flag`
指针是实现标准库中flag包的关键技术，它使用命令行参数来设置对应变量的值，而这些对应命令行标志参数的变量可能会零散分布在整个程序中。

```golang
import "flag"
//...
var n = flag.Bool("n", false, "omit trailing newline") // n 的类型为 *bool
```

### new 函数
```
new(T)
// 内建函数，创建一个类型为 T 的匿名变量，
// 初始化为 T 类型的零值，然后返回变量地址，返回的指针类型为 *T
```

### 变量的生命周期
变量的生命周期指的是在程序运行期间变量有效存在的时间间隔。
* 对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。
* 局部变量的生命周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。
  * 函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。
  * 因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。

需要注意的是，编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，**这个选择并不是由用var还是new声明变量的方式决定的**。

```golang
var global *int

func f() {
    var x int
    // 这里的变量 x 必须在堆上分配，因为它在函数退出后依然可以通过包一级的global变量找到，虽然它是在函数内部定义的。
    // 用 Go 的术语来说，这个x局部变量从函数f中逃逸了。
    x = 1
    global = &x
}

func g() {
    y := new(int)
    // 当g函数返回时，变量*y将是不可达的，也就是说可以马上被回收的。
    // 因此，*y并没有从函数g中逃逸，编译器可以选择在栈上分配*y的存储空间（也可选择在堆上分配）
    *y = 1
}
```

其实在任何时候，你并不需为了编写正确的代码而要考虑变量的逃逸行为，要记住的是，**逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响**。

## 赋值
赋值语句可以用来更新一个变量的值。

```golang
count = count * scale
count *= scale
```

数值变量可以支持 `++` 递增和 `--` 递减语句
```golang
v := 1
v++
v--
```
> 自增和自减是语句，而不是表达式，不允许例如 `x = i++` 这样的操作

### 元组赋值
元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值。

**在赋值之前，赋值语句右边的所有表达式将会先进行求值**，然后再统一更新左边对应变量的值。这对于处理有些同时出现在元组赋值语句左右两边的变量很有帮助。

```golang
x, y = y, x // 交换两个变量的值
```

> 元组赋值也可以使一系列琐碎赋值更加紧凑。但如果表达式太复杂的话，为了可读性，应该尽量避免过度使用元组赋值。

### 可赋值性
赋值语句是显式的赋值形式，但是程序中还有很多地方会发生**隐式的赋值行为**：
* 函数调用会隐式地将调用参数的值赋值给函数的参数变量
* 一个返回语句会隐式地将返回操作的值赋值给结果变量
* 一个复合类型的字面量也会产生赋值行为。

不管是隐式还是显式地赋值，在赋值语句左边的变量和右边最终的求到的值必须有相同的数据类型。即，**只有右边的值对于左边的变量是可赋值的，赋值语句才是允许的**。

可赋值性的一般规则为：类型必须完全匹配，nil可以赋值给任何指针或引用类型的变量。

> 注1：为避免不必要的显式的类型转换，常量有更灵活的赋值规则。

> 注2：对于两个值是否可以用==或!=进行相等比较的能力也和可赋值能力有关系：对于任何类型的值的相等比较，第二个值必须是对第一个值类型对应的变量是可赋值的，反之亦然。

## 类型
变量或表达式的类型定义了对应存储值的属性特征，它们在内部是如何表达的，是否支持一些操作符，以及它们自己关联的方法集等。

一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。
```
type 类型名字 底层类型
```

在任何程序中都会存在一些变量有着相同的内部结构，但是却表示完全不同的概念。因此，新命名的类型提供了一个方法，用来分隔不同概念的类型，这样**即使它们底层类型相同也是不兼容的**。

对于每一个类型T，都有一个对应的类型转换操作 `T(x)`，用于将x转为T类型。
> 注：如果T是指针类型，可能会需要用小括弧包装T，比如 `(*int)(0)`）。
 
只有当**两个类型的底层基础类型相同**时，才允许这种转型操作，或者是两者都是指向相同底层结构的指针类型，这些转换只改变类型而不会影响值本身。

数值类型之间的转型也是允许的，并且在字符串和一些特定类型的slice之间也是可以转换的，这类转换可能改变值的表现。

底层数据类型决定了内部结构和表达方式，也决定了新类型是否可以像底层类型一样对内置运算符的支持。

```golang
type Celsius float64
type Fahrenheit float64

var c Clesius
var f Fahrenheit
// 比较运算符==和<也可以用来比较一个命名类型的变量和另一个有相同类型的变量，
// 或有着相同底层类型的未命名类型的值之间做比较。
fmt.Println(c == 0) // "true"
fmt.Println(f >= 0) // "true"
// 但是如果两个值有着不同的类型，则不能直接进行比较
fmt.Println(c == f) // compile error: type mismatch
fmt.Println(c == Celsius(f)) // "true"
```

命名类型还可以为该类型的值定义新的行为。这些行为表示为一组关联到该类型的函数集合，我们称为类型的方法集。

## 包和文件
一个包的源代码保存在一个或多个以.go为文件后缀名的源文件中，通常一个包所在目录路径的后缀是包的导入路径；例如包 `gopl.io/ch1/helloworld` 对应的目录路径是 `$GOPATH/src/gopl.io/ch1/helloworld`。

每个包都对应一个独立的名字空间。要访问包中的导出函数，必须显式使用诸如 `包名.函数名` 的形式。

包还可以让我们通过控制哪些名字是外部可见的来隐藏内部实现信息。在Go语言中，一个简单的规则是：**如果一个名字是大写字母开头的，那么该名字是导出的。**

在每个源文件的包声明前紧跟着的注释是包注释。通常，包注释的第一句应该先是包的功能概要说明。一个包通常只有一个源文件有包注释（译注：如果有多个包注释，目前的文档工具会根据源文件名的先后顺序将它们链接为一个包注释）。如果包注释很大，通常会放到一个独立的doc.go文件中。

### 导入包
在Go语言程序中，每个包都有一个全局唯一的导入路径。导入语句中类似"gopl.io/ch2/tempconv"的字符串对应包的导入路径。

除了包的导入路径，每个包还有一个包名，包名一般是短小的名字（并不要求包名是唯一的），包名在包的声明处指定。**按照惯例，一个包的名字和包的导入路径的最后一个字段相同**，例如gopl.io/ch2/tempconv包的名字一般是tempconv。

```
import "包的导入路径" // 使用包声明语句指定的名字引用包中导出的内容
// or
import 包别名 "包的导入路径" // 使用包别名引用包中导出的内容
```

注意：如果导入了一个包，但是又没有使用该包将被当作一个编译错误处理。这种强制规则可以有效减少不必要的依赖。

#### `golang.org/x/tools/cmd/goimports`
goimports 可以根据需要自动添加或删除导入的包；许多编辑器都可以集成goimports工具，然后在保存文件的时候自动运行。类似的还有gofmt工具，可以用来格式化Go源文件。

### 包的初始化
包的初始化：
1. 引入的包
2. 当前包中的变量常量
3. 当前包的 `init()`
4. `main()` 函数

包变量常量初始化：
1. 解决包级变量的依赖顺序
2. **按照包级变量声明出现的顺序**依次初始化：
   
```golang
var a = b + c // a 第三个初始化, 为 3
var b = f()   // b 第二个初始化, 为 2, 通过调用 f (依赖c)
var c = 1     // c 第一个初始化, 为 1

func f() int { return c + 1 }
```

如果包中含有多个.go源文件，它们将按照发给编译器的顺序进行初始化，Go语言的构建工具首先会将.go文件**根据文件名排序**，然后依次调用编译器编译。

每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。因此，如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化过了。**初始化工作是自下而上进行的，main包最后被初始化。**以这种方式，可以确保在main函数执行之前，所有依赖的包都已经完成初始化工作了。

#### `init()`
对于在包级别声明的变量，如果有初始化表达式则用表达式初始化，还有一些没有初始化表达式的，可以用一个特殊的 `init` 初始化函数来简化初始化工作。每个文件都可以包含多个 `init` 初始化函数。

```golang
func init(){ /* ... */ }
```

这样的 `init` 初始化函数除了不能被调用或引用外，其他行为和普通函数类似。在每个文件中的 `init` 初始化函数，在程序开始执行时**按照它们声明的顺序**被自动调用。

#### 扩展阅读
* [Program initialization and execution](https://golang.org/ref/spec#Program_initialization_and_execution)

## 作用域
一个声明语句将程序中的实体和一个名字关联，比如一个函数或一个变量。声明语句的作用域是指源代码中可以有效使用这个名字的范围。

声明语句对应的词法域决定了作用域范围的大小。
* 对于内置的类型、函数和常量，比如int、len和true等是在全局作用域的，因此可以在整个程序中直接使用。
* 任何在在函数外部（也就是包级语法域）声明的名字可以在同一个包的任何源文件中访问的。
* 对于导入的包，例如导入的fmt包，则是对应**源文件级**的作用域，因此只能在当前的文件中访问导入的fmt包，当前包的其它源文件无法访问在当前源文件导入的包。
* 还有许多声明语句，比如tempconv.CToF函数中的变量c，则是局部作用域的，它只能在函数内部（甚至只能是局部的某些部分）访问。

控制流标号，就是break、continue或goto语句后面跟着的那种标号，则是函数级的作用域。

在包级别，声明的顺序并不会影响作用域范围，因此一个先声明的可以引用它自身或者是引用后面的一个声明，这可以让我们定义一些相互嵌套或递归的类型或函数。但是如果一个变量或常量递归引用了自身，则会产生编译错误。（*注：这里需要一个例子来解释*）

### 作用域 v.s 生命周期
* 声明语句的作用域对应的是一个源代码的文本区域；
  * 它是一个编译时的属性。
* 一个变量的生命周期是指程序运行时变量存在的有效时间段，在此时间区域内它可以被程序的其他部分引用；
  * 它是一个运行时的概念。


### 当编译器遇到一个名字引用时……
如果该名字引用看起来像一个声明，它首先从最内层的词法域向全局的作用域查找。
* 如果查找失败，则报告“未声明的名字”这样的错误。
* 如果该名字在内部和外部的块分别声明过，则内部块的声明首先被找到。
  * 在这种情况下，**内部声明屏蔽了外部同名的声明**，让外部的声明的名字无法被访问
  
### 隐式词法域
```golang
func main() {
    x := "hello!"
    // 词法域一：循环的初始化部分、条件测试部分和循环后的迭代部分
    for i := 0; i < len(x); i++ { 
        // 词法域二： 循环体词法域
        x := x[i]
        if x != "!" {
            x := x + 'A' - 'a'
            fmt.Printf("%c", x)
        }
    }
}
```

和for循环类似，if和switch语句也会在条件部分创建隐式词法域，还有它们对应的执行体词法域。

### 短变量声明语句的作用域范围
```golang
var cwd string

func init() {
    // 虽然cwd在外部已经声明过，
    // 但是:=语句还是将cwd和err重新声明为新的局部变量。
    cwd, err := os.Getwd() // compile error: unused: cwd
    if err != nil {
        log.Fatalf("os.Getwd failed: %v", err)
    }
}
```
上面的错误最直接的解决方法是通过单独声明 `err` 变量，来避免使用 `:=` 的简短声明方式。