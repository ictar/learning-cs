目录
=================

   * [类型系统](#类型系统)
      * [用户定义的类型](#用户定义的类型)
         * [使用 struct 关键字声明自定义类型](#使用-struct-关键字声明自定义类型)
         * [基于已有类型声明自定义类型](#基于已有类型声明自定义类型)
         * [声明变量](#声明变量)
      * [方法](#方法)
      * [类型的本质](#类型的本质)
         * [内置类型](#内置类型)
         * [引用类型](#引用类型)
         * [结构类型](#结构类型)
      * [接口](#接口)
         * [实现](#实现)
         * [方法集](#方法集)
         * [多态](#多态)
      * [嵌入类型](#嵌入类型)
      * [公开或未公开的标识符](#公开或未公开的标识符)


# 类型系统

## 用户定义的类型
### 使用 `struct` 关键字声明自定义类型
```golang
// 声明类型
type typeName struct {
    fieldname1 fieldtype1
    fieldname2 fieldtype2
}
// fieldtype 可以是内置类型，也可以是其他自定义类型
```

### 基于已有类型声明自定义类型
```golang
type typeName existTypeName
// typeName 和 existTypeName 是两个完全不同的类型，
// 不能直接互相赋值，需要做显式类型转换
```

### 声明变量
```golang
// 任何时候，创建一个变量并初始化为其零值，
// 习惯是使用关键字var。这种用法是为了更明确地表示一个变量被设置为零值。
// 声明 typeName 类型的变量
var varname typeName

// 如果变量被初始化为某个非零值，
// 就配合结构字面量和短变量声明操作符来创建变量。
// 指定字段名的结构字面量，对字段顺序没有要求，结尾也需要逗号
varname := typeName{
    fieldname1: ....,
    fieldname2: ....,
}
// 没有字段名，只声明对应值的结构字面量，值的顺序必须与结构声明中字段顺序一致
```

## 方法
方法实际上也是函数，只是在声明时，在关键字func和方法名之间增加了一个参数
```golang
func (t1 typeName) methodName1() {
    // ...
}
func (t1 *typeName) methodName2() {
    // ...
}
```
上面的参数 `t1` 和 `t2` 称为**接收者**，将函数与接收者的类型绑在一起。其中，`t1` 称为**值接收者**，`t2` 称为**指针接收者**。如果一个函数有接收者，这个函数就被称为**方法**。
* 如果使用值接收者声明方法，方法调用时会使用这个值的一个副本来执行。
* 如果使用指针来调用使用值接收者声明的方法，编译器会隐式将指针解引用为值，再继续调用
* 当调用使用指针接收者声明的方法时，这个方法会共享调用方法时接收者所指向的值。
* 如果使用值来调用使用指针接收者声明的方法，编译器会对值进行调整，使之符合函数的接收者，进行调用。

```golang
type User struct {
	ID, Name string
}

func (u User) modifyID(id string) {
	u.ID = id
}
func (u *User) modifyName(name string) {
	u.Name = name
}
func (u User) String() string {
	return fmt.Sprintf("Id: %s\tName:%s", u.ID, u.Name)
}

func main() {
	usr1 := User{"1", "tester"}
	usr2 := &usr1
	fmt.Printf("usr1:  %s || &usr1: %s\n", usr1, usr2)
	// output:
	// usr1:  Id: 1    Name:tester || &usr1: Id: 1     Name:tester
	usr1.modifyID("2")
	fmt.Printf("usr1:  %s || &usr1: %s\n", usr1, usr2)
	// output:
	// usr1:  Id: 1    Name:tester || &usr1: Id: 1     Name:tester
	usr2.modifyID("3")
	fmt.Printf("usr1:  %s || &usr1: %s\n", usr1, usr2)
	// output:
	// usr1:  Id: 1    Name:tester || &usr1: Id: 1     Name:tester
	usr1.modifyName("developer")
	fmt.Printf("usr1:  %s || &usr1: %s\n", usr1, usr2)
	// output:
	// usr1:  Id: 1    Name:developer || &usr1: Id: 1  Name:developer
	usr2.modifyName("manager")
	fmt.Printf("usr1:  %s || &usr1: %s\n", usr1, usr2)
	// output:
	// usr1:  Id: 1    Name:manager || &usr1: Id: 1    Name:manager
}
```
总结：只有使用指针接收者声明的方法才能修改接收者。而使用值接收者声明的方法不管是使用指针还是使用值调用都不会修改接收者。

## 类型的本质
> 必看！！！
### 内置类型
内置类型是由语言提供的一组类型，分别是数值类型、字符串类型和布尔类型。**这些类型本质上是原始的类型。**因此，当对这些值进行增加或者删除的时候，会创建一个新值。基于这个结论，**当把这些类型的值传递给方法或者函数时，应该传递一个对应值的副本**。

### 引用类型
Go语言里的引用类型有如下几个：切片（slice）、映射（map）、通道（channel）、接口（interface）和函数类型（func）。当声明上述类型的变量时，创建的变量被称作标头（header）值。

每个引用类型创建的标头值是包含一个指向底层数据结构的指针。每个引用类型还包含一组独特的字段，用于管理底层数据结构。因为标头值是为复制而设计的，所以永远不需要共享一个引用类型的值。标头值里包含一个指针，因此**通过复制来传递一个引用类型的值的副本，本质上就是在共享底层数据结构**。

> 注：引用类型的值在其他方面像原始的数据类型的值一样对待。

### 结构类型
结构类型可以用来描述一组数据值，这组值的本质即可以是原始的，也可以是非原始的。
> 如果类型具备“原始的本质”，也就是说它的成员都是由 Go 语言里内置的原始类型（数值类型、字符串类型和布尔类型）

* 如果决定在某些东西需要删除或者添加某个结构类型的值时该结构类型的值不应该被更改（即结构类型的本质是原始的），那么需要遵守前面提到的内置类型和引用类型的规范。

* 如果结构类型的本质是非原始的，对这个类型的值做增加或者删除的操作应该更改值本身。当需要修改值本身时，在程序中其他地方，需要使用指针来共享这个值。

是使用值接收者还是指针接收者，不应该由该方法是否修改了接收到的值来决定，而应该基于该类型的本质。这条规则的一个例外是，需要让类型值符合某个接口的时候，即便类型的本质是非原始本质的，也可以选择使用值接收者声明方法。这样做完全符合接口值调用方法的机制。

## 接口
接口是用来定义行为的类型。这些被定义的行为不由接口直接实现，而是通过方法由用户定义的类型实现。如果用户定义的类型实现了某个接口类型声明的一组方法，那么这个用户定义的类型的值就可以赋给这个接口类型的值。这个赋值会把用户定义的类型的值存入接口类型的值。

**对接口值方法的调用会执行接口值里存储的用户定义的类型的值对应的方法。**因为任何用户定义的类型都可以实现任何接口，所以对接口值方法的调用自然就是一种多态。在这个关系里，用户定义的类型通常叫作**实体类型**，原因是如果离开内部存储的用户定义的类型的值的实现，接口值并没有具体的行为。

### 实现
接口值是一个两个字长度的数据结构：
* 第一个字包含一个指向内部表的指针。
  * 这个内部表叫作iTable，包含了所存储的值的类型信息。
    * iTable包含了已存储的值的类型信息以及与这个值相关联的一组方法。
* 第二个字是一个指向所存储值的指针。

一个指针赋值给接口之后，类型信息会存储一个指向保存的类型的指针，而接口值第二个字依旧保存指向实体值的指针。

### 方法集
方法集定义了一组关联到给定类型的值或者指针的方法。定义方法时使用的接收者的类型决定了这个方法是关联到值，还是关联到指针，还是两个都关联。
| 值 |方法接收者|说明|
|---|---|---|
|`T`|`(t T)`|T类型的值的方法集只包含值接收者声明的方法|
|`*T`|`(t T)` 和 `(t *T)`|指向T类型的指针的方法集既包含值接收者声明的方法，也包含指针接收者声明的方法|

换个角度：
| 方法接收者 |值|说明|
|---|---|---|
|`(t T)`|`T` 和 `*T`|如果使用值接收者来实现一个接口，那么那个类型的值和指针都能够实现对应的接口。|
|`(t *T)`| `*T`|如果使用指针接收者来实现一个接口，那么只有指向那个类型的指针才能够实现对应的接口。|

> 有这种限制的原因是：编译器并不是总能自动获得一个值的地址。

### 多态
1. 定义接口，将接口类型作为函数的参数，在函数中使用接口定义的方法。
2. 自定义类型，实现接口中定义的方法。
3. 将自定义类型的变量作为实参传入到函数中。

## 嵌入类型
Go语言允许用户扩展或者修改已有类型的行为。这个功能对代码复用很重要，在修改已有类型以符合新类型的时候也很重要。这个功能是通过**嵌入类型（type embedding）**完成的，而无需使用继承。嵌入类型是将已有的类型直接声明在新的结构类型里。被嵌入的类型被称为新的外部类型的内部类型。

通过嵌入类型，**与内部类型相关的标识符会提升到外部类型上**。这些被提升的标识符就像直接声明在外部类型里的标识符一样，也是外部类型的一部分。这样外部类型就组合了内部类型包含的所有属性，并且可以添加新的字段和方法。

```golang
type user struct {
	name, email string
}

func (u *user) notify() {
	fmt.Printf("Sending user email to %s<%s>\n",
		u.name, u.email)
}

type admin struct {
	user  // 嵌入类型
	level string
}

func main() {
	ad := admin{
		user: user{ // 内部类型的初始化是用结构字面量完成的。通过内部类型的名字可以访问内部类型
			name:  "tom",
			email: "tom@learning.com",
		},
		level: "super",
	}

    // 可以直接访问内部类型的方法
    // 对外部类型来说，内部类型总是存在的。
    // 这就意味着，虽然没有指定内部类型对应的字段名，还是可以使用内部类型的类型名，来访问到内部类型的值
	ad.user.notify() // "Sending user email to tom<tom@learning.com>"

	// 内部类型的方法也被提升到外部类型
	ad.notify() // "Sending user email to tom<tom@learning.com>"
}
```

外部类型也可以通过声明与内部类型标识符同名的标识符来覆盖内部标识符的字段或者方法。这就是扩展或者修改已有类型的方法。
```golang
type user struct {
	name, email string
}

func (u *user) notify() {
	fmt.Printf("Sending user email to %s<%s>\n",
		u.name, u.email)
}

type admin struct {
	user  // 嵌入类型
	level string
}

// 定义一个同名方法
func (ad *admin) notify() {
	fmt.Printf("Sending %s email to %s<%s>\n",
		ad.level, ad.name, ad.email)
}

func main() {
	ad := admin{
		user: user{
			name:  "tom",
			email: "tom@learning.com",
		},
		level: "super",
	}

	// 可以直接访问内部类型的方法
	ad.user.notify() // "Sending user email to tom<tom@learning.com>"

	// 内部类型的方法被外部类型的方法覆盖
	ad.notify() // "Sending super email to tom<tom@learning.com>"
}
```

## 公开或未公开的标识符
当一个标识符的名字以小写字母开头时，这个标识符就是未公开的，即**包外**的代码不可见。如果一个标识符以大写字母开头，这个标识符就是公开的，即被**包外**的代码可见。

短变量声明操作符，有能力捕获引用的类型，并创建一个未公开的类型的变量。永远不能显式创建一个未公开的类型的变量，不过短变量声明操作符可以这么做。

如果嵌入类型是未公开，那么外部包创建变量时无法直接通过结构字面量的方式初始化该内部类型。不过，即便内部类型是未公开的，内部类型里声明的字段依旧是公开的。既然内部类型的标识符提升到了外部类型，这些公开的字段也可以通过外部类型的字段的值来访问。